{
  "Non Negative Remainder" : {
    "prefix" : "mynonnegativeremainder",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 26afc4b1-71dd-4b0e-9e8c-5c17fbbb2896",
      "infix operator %%: MultiplicationPrecedence",
      "",
      "func %% (lhs: Int, rhs: Int) -> Int {",
      "    let n = lhs % rhs",
      "    return n >= 0 ? n : n + rhs",
      "}",
      "",
      "func testNonnegativeRemainder() {",
      "    assert((-9) %% 3 == 0)",
      "    assert((-8) %% 3 == 1)",
      "    assert((-7) %% 3 == 2)",
      "    assert((-6) %% 3 == 0)",
      "    assert((-5) %% 3 == 1)",
      "    assert((-4) %% 3 == 2)",
      "    assert((-3) %% 3 == 0)",
      "    assert((-2) %% 3 == 1)",
      "    assert((-1) %% 3 == 2)",
      "    assert(0 %% 3 == 0)",
      "    assert(1 %% 3 == 1)",
      "    assert(2 %% 3 == 2)",
      "    assert(3 %% 3 == 0)",
      "    assert(4 %% 3 == 1)",
      "    assert(5 %% 3 == 2)",
      "    assert(6 %% 3 == 0)",
      "    assert(7 %% 3 == 1)",
      "    assert(8 %% 3 == 2)",
      "    assert(9 %% 3 == 0)",
      "}",
      "",
      "testNonnegativeRemainder()",
      ""
    ]
  },
  "Make Directed Graph" : {
    "prefix" : "mymakedirectedgraph",
    "description" : "",
    "body" : [
      "func makeDirectedGraph(_ n: Int, _ A: [Int], _ B: [Int]) -> [[Int]] {",
      "    var result = [[Int]](repeating: [], count: n)",
      "    for (a, b) in zip(A, B) {",
      "        result[a].append(b)",
      "    }",
      "    return result",
      "}",
      ""
    ]
  },
  "Compress" : {
    "prefix" : "mycompress",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 40a2126d-7ac6-4ae9-b182-48911851898d",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "func rank<Element: Comparable & Hashable>(_ a: [Element]) -> [Element: Int] {",
      "    var result = [Element: Int]()",
      "    for x in a.sorted() {",
      "        if !result.keys.contains(x) {",
      "            result[x] = result.count",
      "        }",
      "    }",
      "    return result",
      "}",
      "",
      "extension Array where Element: Comparable & Hashable {",
      "    func compressed() -> [Int] {",
      "        let r = rank(self)",
      "        return map { r[\\$0]! }",
      "    }",
      "}",
      ""
    ]
  },
  "chmin" : {
    "prefix" : "mychmin",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 3e61199e-ddc6-4970-8863-caf671db2ada",
      "func chmin<T: Comparable>(_ x: inout T, _ y: T) {",
      "    x = min(x, y)",
      "}",
      ""
    ]
  },
  "Bitset" : {
    "prefix" : "mybitset",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 44f1e354-8515-4060-8b2c-e1b5668fde5d",
      "\/\/ \/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Bitset: Equatable {",
      "    private var bits: [UInt64]",
      "    let count: Int",
      "",
      "    init(count n: Int) {",
      "        self.count = n",
      "        self.bits = [UInt64](repeating: 0, count: (n + 63) \/ 64)",
      "    }",
      "",
      "    private mutating func normalize() {",
      "        let width = count % 64",
      "        if bits.count > 0 && width != 0 {",
      "            self.bits[bits.count - 1] &= 1 << width - 1",
      "        }",
      "    }",
      "",
      "    subscript(index: Int) -> Bool {",
      "        get {",
      "            self.bits[index \/ 64] >> (index % 64) & 1 == 1",
      "        }",
      "        set {",
      "            if newValue {",
      "                self.bits[index \/ 64] |= 1 << (index % 64)",
      "            } else {",
      "                self.bits[index \/ 64] &= ~(1 << (index % 64))",
      "            }",
      "        }",
      "    }",
      "",
      "    \/\/\/ - Complexity: O(n \/ 64)",
      "    func nonzeroBitCount() -> Int {",
      "        var result = 0",
      "        for i in 0 ..< self.bits.count {",
      "            result += bits[i].nonzeroBitCount",
      "        }",
      "        return result",
      "    }",
      "",
      "    static func == (lhs: Bitset, rhs: Bitset) -> Bool {",
      "        for i in 0 ..< lhs.bits.count {",
      "            if lhs.bits[i] != rhs.bits[i] {",
      "                return false",
      "            }",
      "        }",
      "        return true",
      "    }",
      "",
      "    static prefix func ~ (value: Bitset) -> Bitset {",
      "        var result = Bitset(count: value.count)",
      "        for i in 0 ..< value.bits.count {",
      "            result.bits[i] = ~value.bits[i]",
      "        }",
      "        result.normalize()",
      "        return result",
      "    }",
      "",
      "    static func & (lhs: Bitset, rhs: Bitset) -> Bitset {",
      "        var result = Bitset(count: lhs.count)",
      "        for i in 0 ..< lhs.bits.count {",
      "            result.bits[i] = lhs.bits[i] & rhs.bits[i]",
      "        }",
      "        return result",
      "    }",
      "",
      "    static func &= (lhs: inout Bitset, rhs: Bitset) {",
      "        for i in 0 ..< lhs.bits.count {",
      "            lhs.bits[i] &= rhs.bits[i]",
      "        }",
      "    }",
      "",
      "    static func | (lhs: Bitset, rhs: Bitset) -> Bitset {",
      "        var result = Bitset(count: lhs.count)",
      "        result.bits.withUnsafeMutableBufferPointer { resultBuffer in",
      "            lhs.bits.withUnsafeBufferPointer { lhsBuffer in",
      "                rhs.bits.withUnsafeBufferPointer { rhsBuffer in",
      "                    for i in 0 ..< lhs.bits.count {",
      "                        resultBuffer[i] = lhsBuffer[i] | rhsBuffer[i]",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return result",
      "    }",
      "",
      "    static func |= (lhs: inout Bitset, rhs: Bitset) {",
      "        for i in 0 ..< lhs.bits.count {",
      "            lhs.bits[i] |= rhs.bits[i]",
      "        }",
      "    }",
      "",
      "    static func ^ (lhs: Bitset, rhs: Bitset) -> Bitset {",
      "        var result = Bitset(count: lhs.count)",
      "        for i in 0 ..< lhs.bits.count {",
      "            result.bits[i] = lhs.bits[i] & rhs.bits[i]",
      "        }",
      "        return result",
      "    }",
      "",
      "    static func ^= (lhs: inout Bitset, rhs: Bitset) {",
      "        for i in 0 ..< lhs.bits.count {",
      "            lhs.bits[i] ^= rhs.bits[i]",
      "        }",
      "    }",
      "",
      "    static func << (lhs: Bitset, rhs: Int) -> Bitset {",
      "        precondition(rhs >= 0)",
      "        var result = Bitset(count: lhs.count)",
      "        let large = rhs \/ 64",
      "        let small = rhs % 64",
      "        result.bits.withUnsafeMutableBufferPointer { resultBuffer in",
      "            lhs.bits.withUnsafeBufferPointer { lhsBuffer in",
      "                if large <= lhs.bits.count {",
      "                    for i in 0 ..< lhs.bits.count - large {",
      "                        resultBuffer[i + large] |= lhsBuffer[i] << small",
      "                    }",
      "                }",
      "                if large + 1 <= lhs.bits.count {",
      "                    for i in 0 ..< lhs.bits.count - large - 1 {",
      "                        resultBuffer[i + large + 1] |= lhsBuffer[i] >> (64 - small)",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        result.normalize()",
      "        return result",
      "    }",
      "",
      "    static func <<= (lhs: inout Bitset, rhs: Int) {",
      "        lhs = lhs << rhs",
      "    }",
      "}",
      "",
      "func testBitset() {",
      "    func testLeftShift() {",
      "        var bitset = Bitset(count: 200)",
      "        bitset[1] = true",
      "        bitset[2] = true",
      "        bitset[61] = true",
      "        bitset[63] = true",
      "",
      "        var expected = Bitset(count: 200)",
      "        expected[101] = true",
      "        expected[102] = true",
      "        expected[161] = true",
      "        expected[163] = true",
      "",
      "        assert(bitset << 100 == expected)",
      "    }",
      "}",
      ""
    ]
  },
  "Complex" : {
    "prefix" : "mycomplex",
    "description" : "",
    "body" : [
      "struct Complex: ExpressibleByFloatLiteral, AdditiveArithmetic {",
      "    let x: Double",
      "    let y: Double",
      "",
      "    static var zero: Complex = Complex(0, 0)",
      "    static var one: Complex = Complex(1, 0)",
      "",
      "    var conjugated: Self {",
      "        Complex(x, -y)",
      "    }",
      "",
      "    var absolute: Double {",
      "        norm.squareRoot()",
      "    }",
      "",
      "    var norm: Double {",
      "        x * x + y * y",
      "    }",
      "",
      "    init() {",
      "        self.x = 0",
      "        self.y = 0",
      "    }",
      "",
      "    init(floatLiteral value: FloatLiteralType) {",
      "        self.x = value",
      "        self.y = 0",
      "    }",
      "",
      "    init(_ x: Double) {",
      "        self.x = x",
      "        self.y = 0",
      "    }",
      "",
      "    init(_ x: Double, _ y: Double) {",
      "        self.x = x",
      "        self.y = y",
      "    }",
      "",
      "    static prefix func + (value: Self) -> Self {",
      "        value",
      "    }",
      "",
      "    static prefix func - (value: Self) -> Self {",
      "        Complex(-value.x, -value.y)",
      "    }",
      "",
      "    static func + (lhs: Self, rhs: Self) -> Self {",
      "        Complex(lhs.x + rhs.x, lhs.y + rhs.y)",
      "    }",
      "",
      "    static func += (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs + rhs",
      "    }",
      "",
      "    static func - (lhs: Self, rhs: Self) -> Self {",
      "        Complex(lhs.x - rhs.x, lhs.y - rhs.y)",
      "    }",
      "",
      "    static func -= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs - rhs",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Self) -> Self {",
      "        Complex(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x)",
      "    }",
      "",
      "    static func * (lhs: Double, rhs: Self) -> Self {",
      "        Complex(lhs * rhs.x, lhs * rhs.y)",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Double) -> Self {",
      "        Complex(lhs.x * rhs, lhs.y * rhs)",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Double) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func \/ (lhs: Self, rhs: Double) -> Self {",
      "        Complex(lhs.x \/ rhs, lhs.y \/ rhs)",
      "    }",
      "",
      "    static func \/ (lhs: Double, rhs: Self) -> Self {",
      "        lhs * rhs.conjugated \/ rhs.absolute",
      "    }",
      "",
      "    static func \/ (lhs: Self, rhs: Self) -> Self {",
      "        lhs * rhs.conjugated \/ rhs.norm",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Double) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "}"
    ]
  },
  "Tree Diameter" : {
    "prefix" : "mytreediameter",
    "description" : "",
    "body" : [
      "func treeDiameter(_ G: [[Int]]) -> Int {",
      "    var distance = [Int](repeating: 0, count: G.count)",
      "    func dfs(_ current: Int, _ parent: Int?) {",
      "        for next in G[current] where next != parent {",
      "            distance[next] = distance[current] + 1",
      "            dfs(next, current)",
      "        }",
      "    }",
      "    dfs(0, nil)",
      "    let u = distance.firstIndex(of: distance.max()!)!",
      "    distance[u] = 0",
      "    dfs(u, nil)",
      "    return distance.max()!",
      "}",
      ""
    ]
  },
  "Windows" : {
    "prefix" : "mywindows",
    "description" : "",
    "body" : [
      "extension Sequence {",
      "    \/\/\/ ```",
      "    \/\/\/ assert([].windows(2) == [])",
      "    \/\/\/ assert([1].windows(2) == [])",
      "    \/\/\/ assert([1, 2, 3, 4, 5].windows(2) == [[1, 2], [2, 3], [3, 4], [4, 5]])",
      "    \/\/\/ assert([1, 2, 3, 4, 5].windows(3) == [[1, 2, 3], [2, 3, 4], [3, 4, 5]])",
      "    \/\/\/ ```",
      "    func windows(_ size: Int) -> [[Element]] {",
      "        precondition(size >= 1)",
      "        let array = Array(self)",
      "        guard array.count >= size else { return [] }",
      "        var result: [[Element]] = []",
      "        for i in 0 ... array.count - size {",
      "            result.append(Array(array[i ..< i + size]))",
      "        }",
      "        return result",
      "    }",
      "",
      "    \/\/\/ ```",
      "    \/\/\/ assert([].paired() == []) \/\/ compile error",
      "    \/\/\/ assert([1].paired() == []) \/\/ compile error",
      "    \/\/\/ assert([1, 2, 3, 4, 5].pairWindows() == [(1, 2), (2, 3), (3, 4), (4, 5)]) \/\/ compile error",
      "    \/\/\/ ```",
      "    func paired() -> [(Element, Element)] {",
      "        windows(2).map { (\\$0[0], \\$0[1]) }",
      "    }",
      "}",
      "",
      "func testWindows() {",
      "    assert(([] as [Int]).windows(2) == [])",
      "    assert([1].windows(2) == [])",
      "    assert([1, 2, 3, 4, 5].windows(2) == [[1, 2], [2, 3], [3, 4], [4, 5]])",
      "    assert([1, 2, 3, 4, 5].windows(3) == [[1, 2, 3], [2, 3, 4], [3, 4, 5]])",
      "}",
      "",
      "testWindows()",
      ""
    ]
  },
  "Zn Matrix" : {
    "prefix" : "myznmatrix",
    "description" : "",
    "body" : [
      "struct ZnMatrix {",
      "    private var a: Array2D<Zn>",
      "",
      "    init(_ n: Int) {",
      "        self.a = Array2D<Zn>(repeating: 0, n, n)",
      "    }",
      "",
      "    var size: Int {",
      "        a.n1",
      "    }",
      "",
      "    static func E(_ n: Int) -> ZnMatrix {",
      "        var result = ZnMatrix(n)",
      "        for i in 0 ..< n {",
      "            result[i, i] = 1",
      "        }",
      "        return result",
      "    }",
      "",
      "    subscript(i: Int, j: Int) -> Zn {",
      "        get {",
      "            a[i, j]",
      "        }",
      "        set {",
      "            a[i, j] = newValue",
      "        }",
      "    }",
      "",
      "    static func * (lhs: ZnMatrix, rhs: ZnMatrix) -> ZnMatrix {",
      "        let n = lhs.size",
      "        var result = ZnMatrix(n)",
      "        for i in 0 ..< n {",
      "            for j in 0 ..< n {",
      "                for k in 0 ..< n {",
      "                    result[i, j] += lhs[i, k] * rhs[k, j]",
      "                }",
      "            }",
      "        }",
      "        return result",
      "    }",
      "",
      "    static func ** (lhs: ZnMatrix, rhs: Int) -> ZnMatrix {",
      "        if rhs == 0 {",
      "            return .E(lhs.size)",
      "        } else if rhs % 2 == 1 {",
      "            return lhs * lhs ** (rhs - 1)",
      "        } else {",
      "            return (lhs * lhs) ** (rhs \/ 2)",
      "        }",
      "    }",
      "}"
    ]
  },
  "GCD" : {
    "prefix" : "mygcd",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 049a10cf-8568-424f-a00d-8cc5a3c16068",
      "\/\/\/ `a`と`b`の最大公約数を返す。",
      "\/\/\/",
      "\/\/\/ ```",
      "\/\/\/ assert(gcd(0, 0) == 0)",
      "\/\/\/ assert(gcd(0, 3) == 3)",
      "\/\/\/ assert(gcd(3, 0) == 3)",
      "\/\/\/ assert(gcd(6, 10) == 2)",
      "\/\/\/ assert(gcd(-6, 10) == 2)",
      "\/\/\/ assert(gcd(6, -10) == 2)",
      "\/\/\/ assert(gcd(-6, -10) == 2)",
      "\/\/\/ assert(gcd(11, 13) == 1)",
      "\/\/\/ ```",
      "func gcd(_ a: Int, _ b: Int) -> Int {",
      "    var a = abs(a)",
      "    var b = abs(b)",
      "    while b != 0 {",
      "        (a, b) = (b, a % b)",
      "    }",
      "    return a",
      "}",
      "",
      "func testGCD() {",
      "    assert(gcd(0, 0) == 0)",
      "    assert(gcd(0, 3) == 3)",
      "    assert(gcd(3, 0) == 3)",
      "    assert(gcd(6, 10) == 2)",
      "    assert(gcd(-6, 10) == 2)",
      "    assert(gcd(6, -10) == 2)",
      "    assert(gcd(-6, -10) == 2)",
      "    assert(gcd(11, 13) == 1)",
      "}",
      "",
      "testGCD()",
      ""
    ]
  },
  "Array Lower Bound" : {
    "prefix" : "myarraylowerbound",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 8f13c2c6-8ae3-436d-90da-a0b052b8341f",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "extension Array where Element: Comparable {",
      "    func lowerBound(_ x: Element) -> Int {",
      "        var yes = count",
      "        var no = -1",
      "        while yes - no > 1 {",
      "            let m = (yes + no) \/ 2",
      "            if self[m] >= x {",
      "                yes = m",
      "            } else {",
      "                no = m",
      "            }",
      "        }",
      "        return yes",
      "    }",
      "}",
      "",
      "func testLowerBound() {",
      "    assert([1, 1, 2, 3, 3].lowerBound(0) == 0)",
      "    assert([1, 1, 2, 3, 3].lowerBound(1) == 0)",
      "    assert([1, 1, 2, 3, 3].lowerBound(2) == 2)",
      "    assert([1, 1, 2, 3, 3].lowerBound(3) == 3)",
      "    assert([1, 1, 2, 3, 3].lowerBound(4) == 5)",
      "}",
      "",
      "testLowerBound()"
    ]
  },
  "Static Range Sum" : {
    "prefix" : "mystaticrangesum",
    "description" : "",
    "body" : [
      "struct StaticRangeSum<Element> where Element: AdditiveArithmetic {",
      "    private var prefixSum: [Element]",
      "",
      "    init(repeating value: Element, count: Int) {",
      "        prefixSum = [Element]()",
      "        prefixSum.append(.zero)",
      "        for _ in 0 ..< count {",
      "            prefixSum.append(prefixSum.last! + value)",
      "        }",
      "    }",
      "",
      "    init<S>(_ sequence: S) where S: Sequence, S.Element == Element {",
      "        prefixSum = [Element]()",
      "        prefixSum.append(.zero)",
      "        for element in sequence {",
      "            prefixSum.append(prefixSum.last! + element)",
      "        }",
      "    }",
      "",
      "    subscript(range: UnboundedRange) -> Element {",
      "        prefixSum.last!",
      "    }",
      "",
      "    subscript(range: Range<Int>) -> Element {",
      "        prefixSum[range.upperBound] - prefixSum[range.lowerBound]",
      "    }",
      "",
      "    subscript<R>(range: R) -> Element where R: RangeExpression, R.Bound == Int {",
      "        self[range.relative(to: 0 ..< prefixSum.count - 1)]",
      "    }",
      "}",
      "",
      "func testStaticRangeSum() {",
      "    let sum = StaticRangeSum<Int>([1, 2, 4, 8, 16])",
      "",
      "    assert(sum[...] == 1 + 2 + 4 + 8 + 16)",
      "",
      "    assert(sum[..<0] == 0)",
      "    assert(sum[..<1] == 1)",
      "    assert(sum[..<2] == 1 + 2)",
      "    assert(sum[..<3] == 1 + 2 + 4)",
      "    assert(sum[..<4] == 1 + 2 + 4 + 8)",
      "    assert(sum[..<5] == 1 + 2 + 4 + 8 + 16)",
      "",
      "    assert(sum[...0] == 1)",
      "    assert(sum[...1] == 1 + 2)",
      "    assert(sum[...2] == 1 + 2 + 4)",
      "    assert(sum[...3] == 1 + 2 + 4 + 8)",
      "    assert(sum[...4] == 1 + 2 + 4 + 8 + 16)",
      "",
      "    assert(sum[0...] == 1 + 2 + 4 + 8 + 16)",
      "    assert(sum[1...] == 2 + 4 + 8 + 16)",
      "    assert(sum[2...] == 4 + 8 + 16)",
      "    assert(sum[3...] == 8 + 16)",
      "    assert(sum[4...] == 16)",
      "",
      "    assert(sum[1 ..< 1] == 0)",
      "    assert(sum[1 ..< 2] == 2)",
      "    assert(sum[1 ..< 3] == 2 + 4)",
      "    assert(sum[1 ..< 4] == 2 + 4 + 8)",
      "    assert(sum[1 ..< 5] == 2 + 4 + 8 + 16)",
      "",
      "    assert(sum[1 ... 1] == 2)",
      "    assert(sum[1 ... 2] == 2 + 4)",
      "    assert(sum[1 ... 3] == 2 + 4 + 8)",
      "    assert(sum[1 ... 4] == 2 + 4 + 8 + 16)",
      "}",
      "",
      "testStaticRangeSum()",
      ""
    ]
  },
  "Binary Search" : {
    "prefix" : "mybinarysearch",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: bb85b55e-1021-4f72-a271-5707ac405183",
      "func binarySearch(yes: Int, no: Int, where predicate: (Int) -> Bool) -> Int {",
      "    var yes = yes",
      "    var no = no",
      "    while abs(yes - no) > 1 {",
      "        let x = (yes + no) \/ 2",
      "        if predicate(x) {",
      "            yes = x",
      "        } else {",
      "            no = x",
      "        }",
      "    }",
      "    return yes",
      "}",
      "",
      "func testBinarySearch() {",
      "    assert(binarySearch(yes: 0, no: 100, where: { \\$0 <= 10 }) == 10)",
      "    assert(binarySearch(yes: 100, no: 0, where: { \\$0 >= 10 }) == 10)",
      "    assert(binarySearch(yes: -1, no: 10, where: { \\$0 >= 100 }) == -1)",
      "    assert(binarySearch(yes: 10, no: -1, where: { \\$0 <= -100 }) == 10)",
      "}",
      "",
      "testBinarySearch()"
    ]
  },
  "Optional Apply" : {
    "prefix" : "myoptionalapply",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: ea7826eb-c099-48be-8207-a223e91803ee",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "extension Optional {",
      "    mutating func apply(handler: (inout Wrapped) -> Void) {",
      "        self = map {",
      "            var wrapped = \\$0",
      "            handler(&wrapped)",
      "            return wrapped",
      "        }",
      "    }",
      "}",
      "",
      "func testOptionalApply() {",
      "    struct Dog {",
      "        var apples: Int = 10",
      "",
      "        mutating func eat() {",
      "            apples -= 1",
      "        }",
      "    }",
      "",
      "    func testForSome() {",
      "        var dog: Dog? = .init()",
      "        dog.apply { dog in",
      "            dog.eat()",
      "            dog.eat()",
      "            dog.eat()",
      "        }",
      "        assert(dog?.apples == .some(7))",
      "    }",
      "",
      "    func testForNone() {",
      "        var dog: Dog? = nil",
      "        dog.apply { dog in",
      "            dog.eat()",
      "            dog.eat()",
      "            dog.eat()",
      "        }",
      "        assert(dog?.apples == .none)",
      "    }",
      "",
      "    testForSome()",
      "    testForNone()",
      "}",
      "",
      "testOptionalApply()",
      ""
    ]
  },
  "Divide Then Ceiling" : {
    "prefix" : "myceil",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: cec18690-8918-4c62-99f0-1a8df48d9a43",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "infix operator \/+: MultiplicationPrecedence \/\/ 切り上げ",
      "",
      "\/\/ ceil(lhs\/rhs)と等価。",
      "func \/+ (lhs: Int, rhs: Int) -> Int {",
      "    if rhs < 0 {",
      "        return -lhs \/+ -rhs",
      "    }",
      "    return lhs >= 0 ? (lhs + rhs - 1) \/ rhs : lhs \/ rhs",
      "}",
      "",
      "func testCeilingDivision() {",
      "    assert(0 \/+ 3 == 0)",
      "    assert(5 \/+ 2 == 3)",
      "    assert(6 \/+ 2 == 3)",
      "    assert(-3 \/+ 2 == -1)",
      "    assert(-4 \/+ 2 == -2)",
      "",
      "    assert(0 \/+ -3 == 0)",
      "    assert(-5 \/+ -2 == 3)",
      "    assert(-6 \/+ -2 == 3)",
      "    assert(3 \/+ -2 == -1)",
      "    assert(4 \/+ -2 == -2)",
      "}",
      "",
      "testCeilingDivision()",
      ""
    ]
  },
  "Permutation" : {
    "prefix" : "mypermutation",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 0a8c4b96-aa94-4ae3-b043-3b8db55728ae",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct PermutationSequence<Element: Comparable>: Sequence, IteratorProtocol {",
      "    private var elements: [Element]?",
      "",
      "    mutating func next() -> [Element]? {",
      "        guard let elements = elements else { return nil }",
      "        let results = elements",
      "        var i = elements.count - 2",
      "        while i >= 0, elements[i] >= elements[i + 1] {",
      "            i -= 1",
      "        }",
      "        if i <= -1 {",
      "            self.elements = nil",
      "        } else {",
      "            var j = elements.count - 1",
      "            while elements[i] >= elements[j] {",
      "                j -= 1",
      "            }",
      "            self.elements!.swapAt(i, j)",
      "            self.elements![(i + 1)...].reverse()",
      "        }",
      "        return results",
      "    }",
      "",
      "    init<Elements: Sequence>(elements: Elements) where Elements.Element == Element {",
      "        self.elements = Array(elements).sorted()",
      "    }",
      "",
      "    func makeIterator() -> Iterator {",
      "        self",
      "    }",
      "}",
      "",
      "extension Sequence where Element: Comparable {",
      "    var permutations: PermutationSequence<Element> {",
      "        PermutationSequence(elements: self)",
      "    }",
      "}",
      "",
      "func testPermutations() {",
      "    assert(Array(([] as [Int]).permutations) == [[]])",
      "    assert(Array(([1] as [Int]).permutations) == [[1]])",
      "    assert(Array(([1, 2] as [Int]).permutations) == [[1, 2], [2, 1]])",
      "    assert(Array(([2, 1] as [Int]).permutations) == [[1, 2], [2, 1]])",
      "    assert(Array(([1, 1] as [Int]).permutations) == [[1, 1]])",
      "    assert(",
      "        Array(([1, 2, 3] as [Int]).permutations) ==",
      "            [",
      "                [1, 2, 3],",
      "                [1, 3, 2],",
      "                [2, 1, 3],",
      "                [2, 3, 1],",
      "                [3, 1, 2],",
      "                [3, 2, 1]",
      "            ]",
      "    )",
      "    assert(",
      "        Array(\"abc\".permutations) ==",
      "            [",
      "                [\"a\", \"b\", \"c\"],",
      "                [\"a\", \"c\", \"b\"],",
      "                [\"b\", \"a\", \"c\"],",
      "                [\"b\", \"c\", \"a\"],",
      "                [\"c\", \"a\", \"b\"],",
      "                [\"c\", \"b\", \"a\"]",
      "            ]",
      "    )",
      "    assert(Array(\"aab\".permutations) == [[\"a\", \"a\", \"b\"], [\"a\", \"b\", \"a\"], [\"b\", \"a\", \"a\"]])",
      "}",
      "",
      "testPermutations()",
      ""
    ]
  },
  "Arithmetic Overflow Operator" : {
    "prefix" : "myarithmeticoverflowoperator",
    "description" : "",
    "body" : [
      "infix operator <+>: AdditionPrecedence",
      "infix operator <*>: MultiplicationPrecedence",
      "infix operator <+>=: AssignmentPrecedence",
      "infix operator <*>=: AssignmentPrecedence",
      "",
      "func <+> (lhs: Int, rhs: Int) -> Int {",
      "    let (result, overflow) = lhs.addingReportingOverflow(rhs)",
      "    if overflow {",
      "        return Int.max",
      "    }",
      "    return result",
      "}",
      "",
      "func <*> (lhs: Int, rhs: Int) -> Int {",
      "    let (result, overflow) = lhs.multipliedReportingOverflow(by: rhs)",
      "    if overflow {",
      "        return Int.max",
      "    }",
      "    return result",
      "}",
      "",
      "func <+>= (lhs: inout Int, rhs: Int) {",
      "    lhs = lhs <+> rhs",
      "}",
      "",
      "func <*>= (lhs: inout Int, rhs: Int) {",
      "    lhs = lhs <*> rhs",
      "}"
    ]
  },
  "Array2D" : {
    "prefix" : "myarray2d",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 27d5b702-c362-4a2b-a2da-9f0f366e72b2",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Array2D<Element> {",
      "    let n1: Int",
      "    let n2: Int",
      "    private var elements: [Element]",
      "",
      "    init(repeating: Element, _ n1: Int, _ n2: Int) {",
      "        precondition(n1 >= 0)",
      "        precondition(n2 >= 0)",
      "        self.n1 = n1",
      "        self.n2 = n2",
      "        self.elements = [Element](repeating: repeating, count: n1 * n2)",
      "    }",
      "",
      "    init(_ array: [[Element]]) {",
      "        if array.isEmpty {",
      "            self.n1 = 0",
      "            self.n2 = 0",
      "            self.elements = []",
      "            return",
      "        }",
      "        self.n1 = array.count",
      "        self.n2 = array[0].count",
      "        self.elements = [Element]()",
      "        for i in 0 ..< array.count {",
      "            for j in 0 ..< array[i].count {",
      "                self.elements.append(array[i][j])",
      "            }",
      "        }",
      "    }",
      "",
      "    subscript(i: Int, j: Int) -> Element {",
      "        get {",
      "#if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "#endif",
      "            return elements[i * n2 + j]",
      "        }",
      "        set {",
      "#if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "#endif",
      "            elements[i * n2 + j] = newValue",
      "        }",
      "    }",
      "",
      "    func row(_ i: Int) -> [Element] {",
      "        (0 ..< n2).map { self[i, \\$0] }",
      "    }",
      "",
      "    func column(_ j: Int) -> [Element] {",
      "        (0 ..< n1).map { self[\\$0, j] }",
      "    }",
      "}",
      "",
      "extension Array2D: CustomDebugStringConvertible {",
      "    var debugDescription: String {",
      "        \"[\\n    \" + (0 ..< n1).map { row(\\$0).debugDescription }.joined(separator: \",\\n    \") + \"\\n]\"",
      "    }",
      "}",
      "",
      "func testArray2D() {",
      "    func testDebugStringConvertible() {",
      "        let array = Array2D([[1, 2, 3], [4, 5, 6]])",
      "        assert(array.debugDescription ==",
      "\"\"\"",
      "[",
      "    [1, 2, 3],",
      "    [4, 5, 6]",
      "]",
      "\"\"\")",
      "    }",
      "",
      "    testDebugStringConvertible()",
      "}",
      "",
      "testArray2D()",
      ""
    ]
  },
  "guard self" : {
    "prefix" : "guardself",
    "description" : "",
    "body" : [
      "guard let self = self else { return }"
    ]
  },
  "CountOf" : {
    "prefix" : "mycountof",
    "description" : "",
    "body" : [
      "extension Sequence where Element: Equatable {",
      "    func count(of target: Element) -> Int {",
      "        var result = 0",
      "        for element in self {",
      "            if element == target {",
      "                result += 1",
      "            }",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testCountOf() {",
      "    assert([1, 2, 1, 1, 2].count(of: 1) == 3)",
      "    assert([1, 2, 1, 1, 2].count(of: 2) == 2)",
      "    assert([1, 2, 1, 1, 2].count(of: 3) == 0)",
      "    assert([].count(of: 1) == 0)",
      "}",
      "",
      "testCountOf()"
    ]
  },
  "Make Undirected Graph" : {
    "prefix" : "mymakeundirectedgraph",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: efd5f79e-85ce-41fe-b01c-3a96662ac177",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "func makeUndirectedGraph(_ n: Int, _ A: [Int], _ B: [Int], offset: Int = 0) -> [[Int]] {",
      "    var result = [[Int]](repeating: [], count: n)",
      "    for (a, b) in zip(A, B) {",
      "        result[a - offset].append(b - offset)",
      "        result[b - offset].append(a - offset)",
      "    }",
      "    return result",
      "}"
    ]
  },
  "Gauss Integer" : {
    "prefix" : "myzi",
    "description" : "",
    "body" : [
      "struct Zi: Equatable {",
      "    let x, y: Int",
      "",
      "    static var zero = Zi(x: 0, y: 0)",
      "",
      "    var norm: Int {",
      "        x * x + y * y",
      "    }",
      "",
      "    var conjugate: Zi {",
      "        Zi(x: x, y: -y)",
      "    }",
      "",
      "    static prefix func - (this: Zi) -> Zi {",
      "        Zi(x: -this.x, y: -this.y)",
      "    }",
      "",
      "    static func + (lhs: Zi, rhs: Zi) -> Zi {",
      "        Zi(x: lhs.x + rhs.x, y: lhs.y + rhs.y)",
      "    }",
      "",
      "    static func - (lhs: Zi, rhs: Zi) -> Zi {",
      "        Zi(x: lhs.x - rhs.x, y: lhs.y - rhs.y)",
      "    }",
      "",
      "    static func * (lhs: Zi, rhs: Zi) -> Zi {",
      "        Zi(x: lhs.x * rhs.x - lhs.y * rhs.y, y: lhs.x * rhs.y + lhs.y * rhs.x)",
      "    }",
      "",
      "    static func \/ (lhs: Zi, rhs: Zi) -> Zi {",
      "        let z = lhs * rhs.conjugate",
      "        let n = rhs.norm",
      "        return Zi(x: z.x \/+- n, y: z.y \/+- n)",
      "    }",
      "",
      "    static func % (lhs: Zi, rhs: Zi) -> Zi {",
      "        lhs - (lhs \/ rhs) * rhs",
      "    }",
      "",
      "    func gcd(_ other: Zi) -> Zi {",
      "        if other == .zero {",
      "            return self",
      "        } else {",
      "            return other.gcd(self % other)",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "Run Length Encode" : {
    "prefix" : "myrunlengthencode",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: a1cd2c61-4932-42fe-8a29-9bb5f3ab2f65",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "extension Sequence where Element: Equatable {",
      "    func runLengthEncode() -> [(element: Element, count: Int)] {",
      "        var result = [(element: Element, count: Int)]()",
      "        var previous: Element?",
      "        var count = 0",
      "        for element in self {",
      "            if element != previous {",
      "                if let previous = previous {",
      "                    result.append((element: previous, count: count))",
      "                }",
      "                previous = element",
      "                count = 1",
      "            } else {",
      "                count += 1",
      "            }",
      "        }",
      "        if let previous = previous {",
      "            result.append((element: previous, count: count))",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testRunLengthEncode() {",
      "    func equal<Element1, Element2>(_ a: [(Element1, Element2)], _ b: [(Element1, Element2)]) -> Bool where Element1: Equatable, Element2: Equatable {",
      "        if a.count != b.count {",
      "            return false",
      "        }",
      "        for i in 0 ..< a.count {",
      "            if a[i].0 != b[i].0 || a[i].1 != b[i].1 {",
      "                return false",
      "            }",
      "        }",
      "        return true",
      "    }",
      "",
      "    assert(equal(([] as [Int]).runLengthEncode(), []))",
      "    assert(equal([\"a\"].runLengthEncode(), [(\"a\", 1)]))",
      "    assert(equal([\"a\", \"a\"].runLengthEncode(), [(\"a\", 2)]))",
      "    assert(equal([\"a\", \"a\", \"b\"].runLengthEncode(), [(\"a\", 2), (\"b\", 1)]))",
      "    assert(equal([\"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"c\"].runLengthEncode(), [(\"a\", 2), (\"b\", 3), (\"a\", 2), (\"c\", 1)]))",
      "    assert(equal(\"\".runLengthEncode(), []))",
      "    assert(equal(\"aabbbaac\".runLengthEncode(), [(\"a\", 2), (\"b\", 3), (\"a\", 2), (\"c\", 1)]))",
      "}",
      "",
      "testRunLengthEncode()",
      ""
    ]
  },
  "Prefix Min" : {
    "prefix" : "myprefixmin",
    "description" : "",
    "body" : [
      "extension Array where Element == Int {",
      "    func prefixMin() -> [Element] {",
      "        var result = [Int](repeating: Int.max, count: count + 1)",
      "        for i in 0 ..< count {",
      "            result[i + 1] = Swift.min(result[i], self[i])",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Array Upper Bound" : {
    "prefix" : "myarrayupperbound",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 205bbcf6-55ea-40ba-bf6b-c54e8efe9b90",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "extension Array where Element: Comparable {",
      "    func upperBound(_ x: Element) -> Int {",
      "        var yes = count",
      "        var no = -1",
      "        while yes - no > 1 {",
      "            let m = (yes + no) \/ 2",
      "            if self[m] > x {",
      "                yes = m",
      "            } else {",
      "                no = m",
      "            }",
      "        }",
      "        return yes",
      "    }",
      "}",
      "",
      "",
      "func testUpperBound() {",
      "    assert([1, 1, 2, 3, 3].upperBound(0) == 0)",
      "    assert([1, 1, 2, 3, 3].upperBound(1) == 2)",
      "    assert([1, 1, 2, 3, 3].upperBound(2) == 3)",
      "    assert([1, 1, 2, 3, 3].upperBound(3) == 5)",
      "    assert([1, 1, 2, 3, 3].upperBound(4) == 5)",
      "}",
      "",
      "testUpperBound()"
    ]
  },
  "Static Range Sum 2D" : {
    "prefix" : "mystaticrangesum2d",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 8f2a8e1d-6970-42ee-bc6d-4f1bc819847d",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct StaticRangeSum2D<Element> where Element: AdditiveArithmetic {",
      "    private var sum: Array2D<Element>",
      "",
      "    init(_ array: Array2D<Element>) {",
      "        sum = Array2D<Element>(repeating: .zero, array.n1 + 1, array.n2 + 1)",
      "        for i in 0 ..< array.n1 {",
      "            for j in 0 ..< array.n2 {",
      "                sum[i + 1, j + 1] = sum[i, j + 1] + sum[i + 1, j] - sum[i, j] + array[i, j]",
      "            }",
      "        }",
      "    }",
      "",
      "    subscript(range1: Range<Int>, range2: Range<Int>) -> Element {",
      "        sum[range1.upperBound, range2.upperBound] - sum[range1.lowerBound, range2.upperBound] - sum[range1.upperBound, range2.lowerBound] + sum[range1.lowerBound, range2.lowerBound]",
      "    }",
      "",
      "    subscript(range1: UnboundedRange, range2: UnboundedRange) -> Element {",
      "        self[0 ..< sum.n1 - 1, 0 ..< sum.n2 - 1]",
      "    }",
      "",
      "    subscript<R1>(range1: R1, range2: UnboundedRange) -> Element where R1: RangeExpression, R1.Bound == Int {",
      "        self[range1.relative(to: 0 ..< sum.n1 - 1), 0 ..< sum.n2 - 1]",
      "    }",
      "",
      "    subscript<R2>(range1: UnboundedRange, range2: R2) -> Element where R2: RangeExpression, R2.Bound == Int {",
      "        self[0 ..< sum.n1 - 1, range2.relative(to: 0 ..< sum.n2 - 1)]",
      "    }",
      "",
      "    subscript<R1, R2>(range1: R1, range2: R2) -> Element where R1: RangeExpression, R2: RangeExpression, R1.Bound == Int, R2.Bound == Int {",
      "        self[range1.relative(to: 0 ..< sum.n1 - 1), range2.relative(to: 0 ..< sum.n2 - 1)]",
      "    }",
      "}",
      "",
      "func testStaticRangeSum2D() {",
      "    let sum = StaticRangeSum2D(",
      "        Array2D([",
      "            [1, 2, 3],",
      "            [4, 5, 6],",
      "            [7, 8, 9],",
      "        ])",
      "    )",
      "",
      "    assert(sum[0 ..< 3, 0 ..< 3] == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)",
      "    assert(sum[0 ..< 3, 0 ..< 2] == 1 + 2 + 4 + 5 + 7 + 8)",
      "    assert(sum[0 ..< 2, 0 ..< 2] == 1 + 2 + 4 + 5)",
      "    assert(sum[1 ..< 2, 1 ..< 2] == 5)",
      "    assert(sum[1 ..< 2, 1 ..< 3] == 5 + 6)",
      "    assert(sum[1 ..< 3, 1 ..< 3] == 5 + 6 + 8 + 9)",
      "    assert(sum[2 ..< 3, 2 ..< 3] == 9)",
      "    assert(sum[3 ..< 3, 0 ..< 3] == 0)",
      "    assert(sum[0 ..< 3, 3 ..< 3] == 0)",
      "",
      "    assert(sum[0 ... 2, 0 ... 2] == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)",
      "    assert(sum[0 ... 2, 0 ... 1] == 1 + 2 + 4 + 5 + 7 + 8)",
      "    assert(sum[0 ... 1, 0 ... 1] == 1 + 2 + 4 + 5)",
      "    assert(sum[1 ... 1, 1 ... 1] == 5)",
      "    assert(sum[1 ... 1, 1 ... 2] == 5 + 6)",
      "    assert(sum[1 ... 2, 1 ... 2] == 5 + 6 + 8 + 9)",
      "    assert(sum[2 ... 2, 2 ... 2] == 9)",
      "",
      "    assert(sum[2 ... 2, ...] == 7 + 8 + 9)",
      "    assert(sum[..., 2 ... 2] == 3 + 6 + 9)",
      "",
      "    assert(sum[..., ...] == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)",
      "}",
      "",
      "testStaticRangeSum2D()",
      ""
    ]
  },
  "Sum" : {
    "prefix" : "mysum",
    "description" : "",
    "body" : [
      "prefix operator ∑",
      "",
      "extension Sequence where Element: AdditiveArithmetic {",
      "    func sum() -> Element {",
      "        reduce(.zero, +)",
      "    }",
      "}"
    ]
  },
  "Prefix Max" : {
    "prefix" : "myprefixmax",
    "description" : "",
    "body" : [
      "extension Array where Element == Int {",
      "    func prefixMax() -> [Element] {",
      "        var result = [Int](repeating: Int.min, count: count + 1)",
      "        for i in 0 ..< count {",
      "            result[i + 1] = Swift.max(result[i], self[i])",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Array4D" : {
    "prefix" : "myarray4d",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 3ec5e116-e199-4792-84eb-9525425ec725",
      "\/\/ \/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Array4D<Element> {",
      "    let n1: Int",
      "    let n2: Int",
      "    let n3: Int",
      "    let n4: Int",
      "    private var elements: [Element]",
      "",
      "    init(repeating: Element, _ n1: Int, _ n2: Int, _ n3: Int, _ n4: Int) {",
      "        precondition(n1 >= 0)",
      "        precondition(n2 >= 0)",
      "        precondition(n3 >= 0)",
      "        precondition(n4 >= 0)",
      "        self.n1 = n1",
      "        self.n2 = n2",
      "        self.n3 = n3",
      "        self.n4 = n4",
      "        self.elements = [Element](repeating: repeating, count: n1 * n2 * n3 * n4)",
      "    }",
      "",
      "    subscript(i: Int, j: Int, k: Int, l: Int) -> Element {",
      "        get {",
      "            #if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "            precondition(0 <= k && k < n3)",
      "            precondition(0 <= l && l < n4)",
      "            #endif",
      "            return elements[((i * n2 + j) * n3 + k) * n4 + l]",
      "        }",
      "        set {",
      "            #if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "            precondition(0 <= k && k < n3)",
      "            precondition(0 <= l && l < n4)",
      "            #endif",
      "            elements[((i * n2 + j) * n3 + k) * n4 + l] = newValue",
      "        }",
      "    }",
      "}",
      "",
      ""
    ]
  },
  "Is Prime" : {
    "prefix" : "myisprime",
    "description" : "",
    "body" : [
      "extension Int {",
      "    \/\/\/ ```",
      "    \/\/\/ assert(!1.isPrime())",
      "    \/\/\/ assert(2.isPrime())",
      "    \/\/\/ assert(3.isPrime())",
      "    \/\/\/ assert(!4.isPrime())",
      "    \/\/\/ assert(5.isPrime())",
      "    \/\/\/ assert(!6.isPrime())",
      "    \/\/\/ assert(7.isPrime())",
      "    \/\/\/ assert(!8.isPrime())",
      "    \/\/\/ assert(!9.isPrime())",
      "    \/\/\/ assert(!10.isPrime())",
      "    \/\/\/ ```",
      "    func isPrime() -> Bool {",
      "        guard self >= 2 else { return false }",
      "        var i = 2",
      "        while i * i <= self {",
      "            if self % i == 0 {",
      "                return false",
      "            }",
      "            i += 1",
      "        }",
      "        return true",
      "    }",
      "}",
      "",
      "func testIsPrime() {",
      "    assert(!1.isPrime())",
      "    assert(2.isPrime())",
      "    assert(3.isPrime())",
      "    assert(!4.isPrime())",
      "    assert(5.isPrime())",
      "    assert(!6.isPrime())",
      "    assert(7.isPrime())",
      "    assert(!8.isPrime())",
      "    assert(!9.isPrime())",
      "    assert(!10.isPrime())",
      "}",
      "",
      "testIsPrime()",
      ""
    ]
  },
  "BIT" : {
    "prefix" : "mybit",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: a1cd31a0-4f0e-43ad-ba3f-9dd67501df8c",
      "struct BIT {",
      "    private var elements: [Int]",
      "",
      "    var count: Int {",
      "        elements.count - 1 \/\/ elements[0]を使わないため1を引いておく",
      "    }",
      "",
      "    \/\/\/ 値が`0`で長さが`n`の配列`[0,...,0]`で初期化する",
      "    init(_ n: Int) {",
      "        precondition(n >= 0)",
      "        elements = [Int](repeating: 0, count: n + 1)",
      "    }",
      "",
      "    \/\/\/ `self.elements[at] += value`と同等の操作を行う",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var bit = BIT(5)",
      "    \/\/\/ bit.update(at: 0, 1) \/\/ [1, 0, 0, 0, 0]",
      "    \/\/\/ bit.update(at: 1, 2) \/\/ [1, 2, 0, 0, 0]",
      "    \/\/\/ bit.update(at: 2, 3) \/\/ [1, 2, 3, 0, 0]",
      "    \/\/\/ ```",
      "    mutating func update(at: Int, _ value: Int) {",
      "        precondition((0 ..< count).contains(at))",
      "        var n = at + 1",
      "        while n < elements.count {",
      "            elements[n] += value",
      "            n += n & -n",
      "        }",
      "    }",
      "",
      "    \/\/\/ - Returns: `elements[0 ..< k].reduce(0, +)`",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var bit = BIT(5)",
      "    \/\/\/ bit.update(at: 0, 1) \/\/ [1, 0, 0, 0, 0]",
      "    \/\/\/ bit.update(at: 1, 2) \/\/ [1, 2, 0, 0, 0]",
      "    \/\/\/ bit.update(at: 2, 3) \/\/ [1, 2, 3, 0, 0]",
      "    \/\/\/ assert(bit.sum(0) == 0) \/\/ [1, 2, 3, 0, 0][0 ..< 0].reduce(0, +) == 0",
      "    \/\/\/ assert(bit.sum(1) == 1) \/\/ [1, 2, 3, 0, 0][0 ..< 1].reduce(0, +) == 1",
      "    \/\/\/ assert(bit.sum(2) == 3) \/\/ [1, 2, 3, 0, 0][0 ..< 2].reduce(0, +) == 1 + 2 == 3",
      "    \/\/\/ assert(bit.sum(3) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 3].reduce(0, +) == 1 + 2 + 3 == 6",
      "    \/\/\/ assert(bit.sum(4) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 4].reduce(0, +) == 1 + 2 + 3 + 0 == 6",
      "    \/\/\/ assert(bit.sum(5) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 5].reduce(0, +) == 1 + 2 + 3 + 0 + 0 == 6",
      "    \/\/\/ ```",
      "    func sum(_ k: Int) -> Int {",
      "        precondition((0 ... count).contains(k))",
      "        var n = k",
      "        var result = 0",
      "        while n > 0 {",
      "            result += elements[n]",
      "            n -= n & -n",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testBIT() {",
      "    func testUpdate() {",
      "        var bit = BIT(5)",
      "        bit.update(at: 0, 1) \/\/ [1, 0, 0, 0, 0]",
      "        bit.update(at: 1, 2) \/\/ [1, 2, 0, 0, 0]",
      "        bit.update(at: 2, 3) \/\/ [1, 2, 3, 0, 0]",
      "    }",
      "",
      "    func testSum() {",
      "        var bit = BIT(5)",
      "        bit.update(at: 0, 1) \/\/ [1, 0, 0, 0, 0]",
      "        bit.update(at: 1, 2) \/\/ [1, 2, 0, 0, 0]",
      "        bit.update(at: 2, 3) \/\/ [1, 2, 3, 0, 0]",
      "        assert(bit.sum(0) == 0) \/\/ [1, 2, 3, 0, 0][0 ..< 0].reduce(0, +) == 0",
      "        assert(bit.sum(1) == 1) \/\/ [1, 2, 3, 0, 0][0 ..< 1].reduce(0, +) == 1",
      "        assert(bit.sum(2) == 3) \/\/ [1, 2, 3, 0, 0][0 ..< 2].reduce(0, +) == 1 + 2 == 3",
      "        assert(bit.sum(3) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 3].reduce(0, +) == 1 + 2 + 3 == 6",
      "        assert(bit.sum(4) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 4].reduce(0, +) == 1 + 2 + 3 + 0 == 6",
      "        assert(bit.sum(5) == 6) \/\/ [1, 2, 3, 0, 0][0 ..< 5].reduce(0, +) == 1 + 2 + 3 + 0 + 0 == 6",
      "    }",
      "",
      "    testUpdate()",
      "    testSum()",
      "}",
      "",
      "testBIT()",
      ""
    ]
  },
  "Euler Phi" : {
    "prefix" : "myphi",
    "description" : "",
    "body" : [
      "\/\/\/ [https:\/\/ja.wikipedia.org\/wiki\/オイラーのφ関数](https:\/\/ja.wikipedia.org\/wiki\/オイラーのφ関数)",
      "\/\/\/",
      "\/\/\/ ```",
      "\/\/\/ assert(phi(1) == 1) \/\/ [1]の中で1と互いに素なものは[1]の1つ",
      "\/\/\/ assert(phi(5) == 4) \/\/ [1,2,3,4,5]の中で5と互いに素なものは[1,2,3,4]の4つ",
      "\/\/\/ assert(phi(10) == 4) \/\/ [1,2,3,4,5,6,7,8,9,10]の中で10と互いに素なものは[1,3,7,9]の4つ",
      "\/\/\/ ```",
      "func phi(_ n: Int) -> Int {",
      "    precondition(n >= 1)",
      "    var result = n",
      "    var n = n",
      "    var i = 2",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            result = result \/ i * (i - 1)",
      "            while n % i == 0 {",
      "                n \/= i",
      "            }",
      "        }",
      "        i += 1",
      "    }",
      "    if n != 1 {",
      "        result = result \/ n * (n - 1)",
      "    }",
      "    return result",
      "}",
      "",
      "func testPhi() {",
      "    assert(phi(1) == 1)",
      "    assert(phi(2) == 1)",
      "    assert(phi(3) == 2)",
      "    assert(phi(4) == 2)",
      "    assert(phi(5) == 4)",
      "    assert(phi(6) == 2)",
      "    assert(phi(7) == 6)",
      "    assert(phi(8) == 4)",
      "    assert(phi(9) == 6)",
      "    assert(phi(10) == 4)",
      "}",
      "",
      "testPhi()",
      ""
    ]
  },
  "Point" : {
    "prefix" : "mypoint",
    "description" : "",
    "body" : [
      "struct Point: Equatable {",
      "    let x: Int",
      "    let y: Int",
      "",
      "    init(_ x: Int, _ y: Int) {",
      "        self.x = x",
      "        self.y = y",
      "    }",
      "",
      "    static func - (lhs: Point, rhs: Point) -> Point {",
      "        return Point(lhs.x - rhs.x, lhs.y - rhs.y)",
      "    }",
      "",
      "    func cross(_ other: Point) -> Int {",
      "        return self.x * other.y - self.y * other.x",
      "    }",
      "}"
    ]
  },
  "Zn Complex" : {
    "prefix" : "myzncomplex",
    "description" : "",
    "body" : [
      "struct ZnComplex: ExpressibleByIntegerLiteral, AdditiveArithmetic {",
      "    let x: Zn",
      "    let y: Zn",
      "",
      "    static var zero: ZnComplex = ZnComplex(0, 0)",
      "    static var one: ZnComplex = ZnComplex(1, 0)",
      "    static var I: ZnComplex = ZnComplex(0, 1)",
      "",
      "    var conjugated: Self {",
      "        ZnComplex(x, -y)",
      "    }",
      "",
      "    var norm: Zn {",
      "        x * x + y * y",
      "    }",
      "",
      "    init() {",
      "        self.x = 0",
      "        self.y = 0",
      "    }",
      "",
      "    init(integerLiteral value: IntegerLiteralType) {",
      "        self.x = Zn(value)",
      "        self.y = Zn(0)",
      "    }",
      "",
      "    init(_ x: Zn) {",
      "        self.x = x",
      "        self.y = 0",
      "    }",
      "",
      "    init(_ x: Zn, _ y: Zn) {",
      "        self.x = x",
      "        self.y = y",
      "    }",
      "",
      "    static prefix func + (value: Self) -> Self {",
      "        value",
      "    }",
      "",
      "    static prefix func - (value: Self) -> Self {",
      "        ZnComplex(-value.x, -value.y)",
      "    }",
      "",
      "    static func + (lhs: Self, rhs: Self) -> Self {",
      "        ZnComplex(lhs.x + rhs.x, lhs.y + rhs.y)",
      "    }",
      "",
      "    static func += (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs + rhs",
      "    }",
      "",
      "    static func - (lhs: Self, rhs: Self) -> Self {",
      "        ZnComplex(lhs.x - rhs.x, lhs.y - rhs.y)",
      "    }",
      "",
      "    static func -= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs - rhs",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Self) -> Self {",
      "        ZnComplex(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x)",
      "    }",
      "",
      "    static func * (lhs: Zn, rhs: Self) -> Self {",
      "        ZnComplex(lhs * rhs.x, lhs * rhs.y)",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Zn) -> Self {",
      "        ZnComplex(lhs.x * rhs, lhs.y * rhs)",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Zn) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func \/ (lhs: Self, rhs: Zn) -> Self {",
      "        ZnComplex(lhs.x \/ rhs, lhs.y \/ rhs)",
      "    }",
      "",
      "    static func \/ (lhs: Zn, rhs: Self) -> Self {",
      "        lhs * rhs.conjugated \/ rhs.norm",
      "    }",
      "",
      "    static func \/ (lhs: Self, rhs: Self) -> Self {",
      "        lhs * rhs.conjugated \/ rhs.norm",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Zn) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "",
      "    static func ** (lhs: Self, rhs: Int) -> Self {",
      "        lhs.pow(rhs)",
      "    }",
      "",
      "    func pow(_ n: Int) -> Self {",
      "        var result: ZnComplex = 1",
      "        var x: ZnComplex = self",
      "        var n = n",
      "        while n > 0 {",
      "            if n & 1 == 1 {",
      "                result *= x",
      "            }",
      "            x *= x",
      "            n >>= 1",
      "        }",
      "        return result",
      "    }",
      "}",
      ""
    ]
  },
  "Positional Notation" : {
    "prefix" : "mypositionalnotation",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: c3cdf631-5bd3-4eaa-823b-4743725b964f",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "extension Int {",
      "    func positionalNotation(base: Int) -> [Int] {",
      "        var result: [Int] = []",
      "        var n = self",
      "        while n > 0 {",
      "            result.append(n % base)",
      "            n \/= base",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testPositionalNotation() {",
      "    assert(0.positionalNotation(base: 2) == [])",
      "    assert(1.positionalNotation(base: 2) == [1])",
      "    assert(2.positionalNotation(base: 2) == [0, 1])",
      "    assert(3.positionalNotation(base: 2) == [1, 1])",
      "    assert(4.positionalNotation(base: 2) == [0, 0, 1])",
      "    assert(0.positionalNotation(base: 3) == [])",
      "    assert(1.positionalNotation(base: 3) == [1])",
      "    assert(2.positionalNotation(base: 3) == [2])",
      "    assert(3.positionalNotation(base: 3) == [0, 1])",
      "    assert(4.positionalNotation(base: 3) == [1, 1])",
      "    assert(5.positionalNotation(base: 3) == [2, 1])",
      "    assert(6.positionalNotation(base: 3) == [0, 2])",
      "}",
      "",
      "testPositionalNotation()",
      ""
    ]
  },
  "Array3D" : {
    "prefix" : "myarray3d",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 1a5e73a2-96a8-4b3e-8d8b-05eee049765c",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Array3D<Element> {",
      "    let n1: Int",
      "    let n2: Int",
      "    let n3: Int",
      "    private var elements: [Element]",
      "",
      "    init(repeating: Element, _ n1: Int, _ n2: Int, _ n3: Int) {",
      "        precondition(n1 >= 0)",
      "        precondition(n2 >= 0)",
      "        precondition(n3 >= 0)",
      "        self.n1 = n1",
      "        self.n2 = n2",
      "        self.n3 = n3",
      "        self.elements = [Element](repeating: repeating, count: n1 * n2 * n3)",
      "    }",
      "",
      "    subscript(i: Int, j: Int, k: Int) -> Element {",
      "        get {",
      "            #if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "            #endif",
      "            return elements[(i * n2 + j) * n3 + k]",
      "        }",
      "        set {",
      "            #if DEBUG",
      "            precondition(0 <= i && i < n1)",
      "            precondition(0 <= j && j < n2)",
      "            #endif",
      "            elements[(i * n2 + j) * n3 + k] = newValue",
      "        }",
      "    }",
      "}",
      "",
      ""
    ]
  },
  "Latin Index" : {
    "prefix" : "mylatinindex",
    "description" : "",
    "body" : [
      "extension Character {",
      "    var lowercaseLatinIndex: Int? {",
      "        if let c = self.asciiValue {",
      "            if (\"a\" as Character).asciiValue! <= c && c <= (\"z\" as Character).asciiValue! {",
      "                return Int(c - (\"a\" as Character).asciiValue!)",
      "            } else {",
      "                return nil",
      "            }",
      "        } else {",
      "            return nil",
      "        }",
      "    }",
      "",
      "    var uppercaseLatinIndex: Int? {",
      "        if let c = self.asciiValue {",
      "            if (\"A\" as Character).asciiValue! <= c && c <= (\"Z\" as Character).asciiValue! {",
      "                return Int(c - (\"A\" as Character).asciiValue!)",
      "            } else {",
      "                return nil",
      "            }",
      "        } else {",
      "            return nil",
      "        }",
      "    }",
      "}",
      "",
      "func testLowercaseLatinIndex() {",
      "    assert((\"a\" as Character).lowercaseLatinIndex == .some(0))",
      "    assert((\"j\" as Character).lowercaseLatinIndex == .some(9))",
      "    assert((\"A\" as Character).lowercaseLatinIndex == .none)",
      "    assert((\"J\" as Character).lowercaseLatinIndex == .none)",
      "    assert((\" \" as Character).lowercaseLatinIndex == .none)",
      "    assert((\"あ\" as Character).lowercaseLatinIndex == .none)",
      "    assert((\"阿\" as Character).lowercaseLatinIndex == .none)",
      "    assert(\"abcdabc\".map(\\.lowercaseLatinIndex!) == [0, 1, 2, 3, 0, 1, 2])",
      "}",
      "",
      "func testUppercaseLatinIndex() {",
      "    assert((\"a\" as Character).uppercaseLatinIndex == .none)",
      "    assert((\"j\" as Character).uppercaseLatinIndex == .none)",
      "    assert((\"A\" as Character).uppercaseLatinIndex == .some(0))",
      "    assert((\"J\" as Character).uppercaseLatinIndex == .some(9))",
      "    assert((\" \" as Character).uppercaseLatinIndex == .none)",
      "    assert((\"あ\" as Character).uppercaseLatinIndex == .none)",
      "    assert((\"阿\" as Character).uppercaseLatinIndex == .none)",
      "    assert(\"ABCDABC\".map(\\.uppercaseLatinIndex!) == [0, 1, 2, 3, 0, 1, 2])",
      "}",
      "",
      "testLowercaseLatinIndex()",
      "testUppercaseLatinIndex()",
      ""
    ]
  },
  "Binary Search over Floating Point Number" : {
    "prefix" : "myrealbinarysearch",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: c29955e9-f71e-436f-94d6-98df5492f8e1",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "func binarySearch(yes: Double, no: Double, iteration: Int, predicate: (Double) -> Bool) -> Double {",
      "    func f(yes: Double, no: Double, iteration: Int) -> Double {",
      "        if iteration <= 0 {",
      "            return yes",
      "        }",
      "        let x = (yes + no) \/ 2",
      "        if predicate(x) {",
      "            return f(yes: x, no: no, iteration: iteration - 1)",
      "        } else {",
      "            return f(yes: yes, no: x, iteration: iteration - 1)",
      "        }",
      "    }",
      "    return f(yes: yes, no: no, iteration: iteration)",
      "}",
      "",
      "func testBinarySearchOverReal() {",
      "    assert(abs(binarySearch(yes: 10, no: 0, iteration: 100) { x in",
      "        x * x >= 4",
      "    }) - 2 < 1e-6)",
      "    assert(abs(binarySearch(yes: 0, no: 10, iteration: 100) { x in",
      "        x * x <= 4",
      "    }) - 2 < 1e-6)",
      "}",
      "",
      "testBinarySearchOverReal()"
    ]
  },
  "Nearest Rounding" : {
    "prefix" : "myround",
    "description" : "",
    "body" : [
      "infix operator \/+-: MultiplicationPrecedence \/\/ 四捨五入",
      "func \/+- (lhs: Int, rhs: Int) -> Int {",
      "    (2 * lhs + 1) \/- (2 * rhs)",
      "}"
    ]
  },
  "chmax" : {
    "prefix" : "mychmax",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: c829a679-1f44-40c6-9422-bd90be99f81f",
      "func chmax<T: Comparable>(_ x: inout T, _ y: T) {",
      "    x = max(x, y)",
      "}"
    ]
  },
  "Extended Euclidean Algorithm" : {
    "prefix" : "myextgcd",
    "description" : "",
    "body" : [
      "\/\/\/ `a`と`b`の最大公約数を`g`として、`ax + by = g`を満たす整数`x`と`y`および`g`の組を返す。",
      "\/\/\/",
      "\/\/\/ ```",
      "\/\/\/ let (x, y, g) = extendedGCD(-6, 10)",
      "\/\/\/ assert(g == 2)",
      "\/\/\/ assert(-6 * x + 10 * y == g)",
      "\/\/\/ ```",
      "func extendedGCD(_ a: Int, _ b: Int) -> (x: Int, y: Int, g: Int) {",
      "    var x1 = 1, y1 = 0, z1 = a",
      "    var x2 = 0, y2 = 1, z2 = b",
      "    while z2 != 0 {",
      "        let q = z1 \/ z2",
      "        (x1, x2) = (x2, x1 - x2 * q)",
      "        (y1, y2) = (y2, y1 - y2 * q)",
      "        (z1, z2) = (z2, z1 - z2 * q)",
      "    }",
      "    if z1 >= 0 {",
      "        return (x: x1, y: y1, g: z1)",
      "    } else {",
      "        return (x: -x1, y: -y1, g: -z1)",
      "    }",
      "}",
      "",
      "func testExtendedGCD() {",
      "    let (x, y, g) = extendedGCD(-6, 10)",
      "    assert(g == 2)",
      "    assert(-6 * x + 10 * y == g)",
      "}",
      "",
      "testExtendedGCD()"
    ]
  },
  "Or Assignment Operator" : {
    "prefix" : "myorassignment",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 479ac407-934b-47be-b700-b4cbafab5f77",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "infix operator ||=: AssignmentPrecedence",
      "",
      "\/**",
      " - Remark:",
      " 短絡評価されないので注意。",
      " たとえば`x`が`true`の場合、`x = x || f()`では`f()`は評価されないが、`x ||= f()`では`f()`は評価される。",
      " *\/",
      "func ||= (lhs: inout Bool, rhs: Bool) {",
      "    lhs = lhs || rhs",
      "}",
      ""
    ]
  },
  "Uniqued Comparable" : {
    "prefix" : "myuniquedcomparable",
    "description" : "",
    "body" : [
      "extension Array where Element: Comparable {",
      "    func uniqued() -> [Element] {",
      "        var result = [Element]()",
      "        for element in sorted() where element != result.last {",
      "            result.append(element)",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Sort Tuple" : {
    "prefix" : "mysorttuple",
    "description" : "",
    "body" : [
      "func sort<A, B>(_ a: [A], _ b: [B], by compare: ((A, B), (A, B)) -> Bool) -> ([A], [B]) where A: Comparable, B: Comparable {",
      "    let ab = zip(a, b).sorted(by: compare)",
      "    return (ab.map(\\.0), ab.map(\\.1))",
      "}",
      "",
      "func sort<A, B, C>(_ a: [A], _ b: [B], _ c: [C], by compare: ((A, B, C), (A, B, C)) -> Bool) -> ([A], [B], [C]) where A: Comparable, B: Comparable, C: Comparable {",
      "    let abc = zip(a, b, c).sorted(by: compare)",
      "    return (abc.map(\\.0), abc.map(\\.1), abc.map(\\.2))",
      "}",
      "",
      "func sort<A, B, C, D>(_ a: [A], _ b: [B], _ c: [C], _ d: [D], by compare: ((A, B, C, D), (A, B, C, D)) -> Bool) -> ([A], [B], [C], [D]) where A: Comparable, B: Comparable, C: Comparable, D: Comparable {",
      "    let abcd = zip(a, b, c, d).sorted(by: compare)",
      "    return (abcd.map(\\.0), abcd.map(\\.1), abcd.map(\\.2), abcd.map(\\.3))",
      "}"
    ]
  },
  "Counter" : {
    "prefix" : "mycounter",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: a04cc5b1-b58c-4107-8fae-87d935169ebc",
      "struct Counter<Key: Hashable> {",
      "    private var count: [Key: Int] = [:]",
      "",
      "    init() {",
      "",
      "    }",
      "",
      "    init<S>(_ sequence: S) where S: Sequence, S.Element == Key {",
      "        for element in sequence {",
      "            self[element] += 1",
      "        }",
      "    }",
      "",
      "    var keys: Dictionary<Key, Int>.Keys {",
      "        count.keys",
      "    }",
      "",
      "    subscript(_ key: Key) -> Int {",
      "        get {",
      "            count[key, default: 0]",
      "        }",
      "        set {",
      "            count[key, default: 0] = newValue",
      "        }",
      "    }",
      "}"
    ]
  },
  "Rational" : {
    "prefix" : "myrational",
    "description" : "",
    "body" : [
      "struct Rational: ExpressibleByIntegerLiteral, AdditiveArithmetic, Comparable, Hashable, CustomStringConvertible {",
      "    private let a: Int",
      "    private let b: Int",
      "",
      "    static var zero: Self = .init(0, 1)",
      "",
      "    init(integerLiteral value: IntegerLiteralType) {",
      "        self.init(value)",
      "    }",
      "",
      "    init(_ a: Int) {",
      "        self.a = a",
      "        self.b = 1",
      "    }",
      "",
      "    init(_ a: Int, _ b: Int) {",
      "        assert(b != 0)",
      "        let g = Rational.gcd(abs(a), abs(b))",
      "        if b > 0 {",
      "            self.a = a \/ g",
      "            self.b = b \/ g",
      "        } else {",
      "            self.a = -a \/ g",
      "            self.b = -b \/ g",
      "        }",
      "    }",
      "",
      "    private static func gcd(_ x: Int, _ y: Int) -> Int {",
      "        if y == 0 {",
      "            return x",
      "        } else {",
      "            return gcd(y, x % y)",
      "        }",
      "    }",
      "",
      "    static prefix func - (value: Self) -> Self {",
      "        Self(-value.a, value.b)",
      "    }",
      "",
      "    static func + (lhs: Self, rhs: Self) -> Self {",
      "        Self(lhs.a * rhs.b + rhs.a * lhs.b, lhs.b * rhs.b)",
      "    }",
      "",
      "    static func += (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs + rhs",
      "    }",
      "",
      "    static func - (lhs: Self, rhs: Self) -> Self {",
      "        lhs + -rhs",
      "    }",
      "",
      "    static func -= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs - rhs",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Self) -> Self {",
      "        Self(lhs.a * rhs.a, lhs.b * rhs.b)",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func \/ (lhs: Self, rhs: Self) -> Self {",
      "        Self(lhs.a * rhs.b, lhs.b * rhs.a)",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "",
      "    static func < (lhs: Self, rhs: Self) -> Bool {",
      "        lhs.a * rhs.b < rhs.a * lhs.b",
      "    }",
      "",
      "    var description: String {",
      "        String(a) + \"\/\" + String(b)",
      "    }",
      "}",
      "",
      "func testRational() {",
      "    func testInit() {",
      "        assert(Rational(-1, 2) == Rational(1, -2))",
      "        assert(Rational(-1, -2) == Rational(1, 2))",
      "        assert(Rational(-2, -4) == Rational(1, 2))",
      "        assert(Rational(-2, 4) == Rational(-1, 2))",
      "        assert(Rational(2, -4) == Rational(-1, 2))",
      "    }",
      "",
      "    func testAddition() {",
      "        assert(Rational(1, 2) + Rational(1, 3) == Rational(5, 6))",
      "        assert(Rational(2, 4) + Rational(2, 6) == Rational(5, 6))",
      "    }",
      "",
      "    func testSubtraction() {",
      "        assert(Rational(1, 2) - Rational(1, 3) == Rational(1, 6))",
      "        assert(Rational(1, 3) - Rational(1, 2) == Rational(-1, 6))",
      "    }",
      "",
      "    func testMultiplication() {",
      "        assert(Rational(2, 3) * Rational(5, 7) == Rational(10, 21))",
      "        assert(Rational(2, 6) * Rational(10, 7) == Rational(10, 21))",
      "        assert(Rational(-2, 3) * Rational(5, 7) == Rational(-10, 21))",
      "        assert(Rational(2, 3) * Rational(-5, 7) == Rational(-10, 21))",
      "        assert(Rational(-2, 3) * Rational(-5, 7) == Rational(10, 21))",
      "    }",
      "",
      "    func testDivision() {",
      "        assert(Rational(2, 3) \/ Rational(5, 7) == Rational(14, 15))",
      "        assert(Rational(2, 6) \/ Rational(10, 7) == Rational(7, 30))",
      "        assert(Rational(-2, 3) \/ Rational(5, 7) == Rational(-14, 15))",
      "        assert(Rational(2, 3) \/ Rational(-5, 7) == Rational(-14, 15))",
      "        assert(Rational(-2, 3) \/ Rational(-5, 7) == Rational(14, 15))",
      "    }",
      "",
      "    func testLessThan() {",
      "        assert(Rational(1, 3) < Rational(1, 2))",
      "        assert(!(Rational(1, 2) < Rational(1, 2)))",
      "        assert(!(Rational(1, 2) < Rational(1, 3)))",
      "    }",
      "",
      "    testInit()",
      "    testAddition()",
      "    testSubtraction()",
      "    testMultiplication()",
      "    testDivision()",
      "    testLessThan()",
      "}",
      "",
      "testRational()"
    ]
  },
  "Int Set Algebra" : {
    "prefix" : "myintsetalgebra",
    "description" : "",
    "body" : [
      "extension Int: SetAlgebra {",
      "    public typealias Element = Int",
      "",
      "    public func contains(_ member: Element) -> Bool {",
      "        self >> member & 1 == 1",
      "    }",
      "",
      "    public func intersection(_ other: Self) -> Self {",
      "        self & other",
      "    }",
      "",
      "    public func union(_ other: Self) -> Self {",
      "        self | other",
      "    }",
      "",
      "    public func symmetricDifference(_ other: Self) -> Self {",
      "        self ^ other",
      "    }",
      "",
      "    public mutating func formIntersection(_ other: Self) {",
      "        self &= other",
      "    }",
      "",
      "    public mutating func formUnion(_ other: Self) {",
      "        self |= other",
      "    }",
      "",
      "    public mutating func formSymmetricDifference(_ other: Self) {",
      "        self ^= other",
      "    }",
      "",
      "    public mutating func insert(_ newMember: Element) -> (inserted: Bool, memberAfterInsert: Element) {",
      "        if contains(newMember) {",
      "            return (false, newMember)",
      "        } else {",
      "            self |= 1 << newMember",
      "            return (true, newMember)",
      "        }",
      "    }",
      "",
      "    public mutating func remove(_ member: Element) -> Element? {",
      "        if contains(member) {",
      "            self &= ~(1 << member)",
      "            return member",
      "        } else {",
      "            return nil",
      "        }",
      "    }",
      "",
      "    public mutating func update(with newMember: Element) -> Element? {",
      "        if contains(newMember) {",
      "            return newMember",
      "        } else {",
      "            self |= 1 << newMember",
      "            return nil",
      "        }",
      "    }",
      "}",
      "",
      "func testIntSetAlgebra() {",
      "    func testContains() {",
      "        assert(!Int([1, 2, 4, 5]).contains(0))",
      "        assert(Int([1, 2, 4, 5]).contains(1))",
      "        assert(Int([1, 2, 4, 5]).contains(2))",
      "        assert(!Int([1, 2, 4, 5]).contains(3))",
      "        assert(Int([1, 2, 4, 5]).contains(4))",
      "        assert(Int([1, 2, 4, 5]).contains(5))",
      "        assert(!Int([1, 2, 4, 5]).contains(6))",
      "    }",
      "",
      "    func testIntersection() {",
      "        assert(([1, 2, 3, 4] as Int).intersection([2, 3, 4, 5]) == [2, 3, 4])",
      "    }",
      "",
      "    func testUnion() {",
      "        assert(([1, 2, 3, 4] as Int).union([2, 3, 4, 5]) == [1, 2, 3, 4, 5])",
      "    }",
      "",
      "    func testSymmetricDifference() {",
      "        assert(([1, 2, 3, 4] as Int).symmetricDifference([2, 3, 4, 5]) == [1, 5])",
      "    }",
      "",
      "    func testInsert() {",
      "        var s: Int = []",
      "        assert(s.insert(0) == (true, 0))",
      "        assert(s.insert(1) == (true, 1))",
      "        assert(s.insert(0) == (false, 0))",
      "        assert(s.insert(1) == (false, 1))",
      "        assert(s.insert(2) == (true, 2))",
      "        assert(s == [0, 1, 2])",
      "    }",
      "",
      "    func testRemove() {",
      "        var s: Int = []",
      "        assert(s.remove(0) == nil)",
      "        assert(s.insert(0) == (true, 0))",
      "        assert(s.insert(1) == (true, 1))",
      "        assert(s.remove(0) == 0)",
      "        assert(s.insert(0) == (true, 0))",
      "        assert(s.insert(0) == (false, 0))",
      "        assert(s.remove(1) == 1)",
      "        assert(s == [0])",
      "    }",
      "",
      "    func testUpdate() {",
      "        var s: Int = []",
      "        assert(s.update(with: 0) == nil)",
      "        assert(s.update(with: 1) == nil)",
      "        assert(s.update(with: 0) == 0)",
      "        assert(s.update(with: 2) == nil)",
      "        assert(s.update(with: 2) == 2)",
      "        assert(s.update(with: 1) == 1)",
      "    }",
      "",
      "    testContains()",
      "    testIntersection()",
      "    testUnion()",
      "    testSymmetricDifference()",
      "    testInsert()",
      "    testRemove()",
      "    testUpdate()",
      "}",
      "",
      "testIntSetAlgebra()",
      ""
    ]
  },
  "Slope Trick" : {
    "prefix" : "",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 79d428a6-df9f-4e13-895a-9171caa1a31b",
      "struct SlopeTrick {",
      "    private var addLeft: Int = 0",
      "    private var addRight: Int = 0",
      "    private var left: BinaryHeap<Int>",
      "    private var right: BinaryHeap<Int>",
      "    private var minimum: Int",
      "",
      "    init() {",
      "        self.left = .init(lessThan: >)",
      "        self.right = .init(lessThan: <)",
      "        self.minimum = 0",
      "    }",
      "",
      "    private mutating func insertLeft(_ x: Int) {",
      "        left.insert(x + addLeft)",
      "    }",
      "",
      "    private func peekLeft() -> Int {",
      "        left.peekMin()! - addLeft",
      "    }",
      "",
      "    private mutating func popLeft() -> Int {",
      "        left.extractMin()! - addLeft",
      "    }",
      "",
      "    private mutating func insertRight(_ x: Int) {",
      "        right.insert(x - addRight)",
      "    }",
      "",
      "    func peekRight() -> Int {",
      "        right.peekMin()! + addRight",
      "    }",
      "",
      "    private mutating func popRight() -> Int {",
      "        right.extractMin()! + addRight",
      "    }",
      "",
      "    \/\/ add max(0, x - a)",
      "    mutating func addPlus(_ a: Int) {",
      "        if !left.isEmpty {",
      "            minimum += max(0, peekLeft() - a)",
      "        }",
      "        insertLeft(a)",
      "        insertRight(popLeft())",
      "    }",
      "",
      "    \/\/ add max(0, a - x)",
      "    mutating func addMinus(_ a: Int) {",
      "        if !right.isEmpty {",
      "            minimum += max(0, a - peekRight())",
      "        }",
      "        insertRight(a)",
      "        insertLeft(popRight())",
      "    }",
      "",
      "    mutating func expand(_ x: Int) {",
      "        addLeft += x",
      "        addRight += x",
      "    }",
      "",
      "    func findMinimum() -> Int {",
      "        minimum",
      "    }",
      "}",
      ""
    ]
  },
  "Suffix Min" : {
    "prefix" : "mysuffixmin",
    "description" : "",
    "body" : [
      "extension Array where Element == Int {",
      "    func suffixMin() -> [Element] {",
      "        var result = [Int](repeating: Int.max, count: count + 1)",
      "        for i in (0 ..< count).reversed() {",
      "            result[i] = Swift.min(self[i], result[i + 1])",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Suffix Max" : {
    "prefix" : "mysuffixmax",
    "description" : "",
    "body" : [
      "extension Array where Element == Int {",
      "    func suffixMax() -> [Element] {",
      "        var result = [Int](repeating: Int.min, count: count + 1)",
      "        for i in (0 ..< count).reversed() {",
      "            result[i] = Swift.max(self[i], result[i + 1])",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Eratosthenes" : {
    "prefix" : "myeratosthenes",
    "description" : "",
    "body" : [
      "func eratosthenes(through n: Int) -> [Bool] {",
      "    precondition(n >= 0)",
      "    if n == 0 {",
      "        return [false]",
      "    }",
      "    if n == 1 {",
      "        return [false, false]",
      "    }",
      "    var table = [Bool](repeating: true, count: n + 1)",
      "    table[0] = false",
      "    table[1] = false",
      "    for i in 2 ... n where table[i] {",
      "        for j in stride(from: i * 2, through: n, by: i) {",
      "            table[j] = false",
      "        }",
      "    }",
      "    return table",
      "}",
      "",
      "func testEratosthenes() {",
      "    assert(eratosthenes(through: 0) == [false])",
      "    assert(eratosthenes(through: 1) == [false, false])",
      "    assert(eratosthenes(through: 2) == [false, false, true])",
      "    assert(eratosthenes(through: 3) == [false, false, true, true])",
      "    assert(eratosthenes(through: 4) == [false, false, true, true, false])",
      "    assert(eratosthenes(through: 5) == [false, false, true, true, false, true])",
      "    assert(",
      "        eratosthenes(through: 20) == [",
      "            false, false, true, true, false,",
      "            true, false, true, false, false,",
      "            false, true, false, true, false,",
      "            false, false, true, false, true,",
      "            false",
      "        ]",
      "    )",
      "}",
      "",
      "testEratosthenes()",
      ""
    ]
  },
  "Power" : {
    "prefix" : "mypower",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 2b93f6b6-6891-4e09-b83b-a4b31ce771c2",
      "precedencegroup PowerPrecedence {",
      "    higherThan: MultiplicationPrecedence",
      "    associativity: right",
      "}",
      "",
      "infix operator **: PowerPrecedence",
      "",
      "func ** (lhs: Int, rhs: Int) -> Int {",
      "    rhs == 0 ? 1 : lhs * lhs ** (rhs - 1)",
      "}"
    ]
  },
  "Fast IO" : {
    "prefix" : "myfastio",
    "description" : "",
    "body" : [
      "struct Printer {",
      "    private let bufferSize = 4096 * 4",
      "    private var data: [UInt8]",
      "    private var index: Int = 0",
      "    private var intBuffer: [UInt8]",
      "",
      "    init() {",
      "        data = .init(repeating: 0, count: bufferSize)",
      "        intBuffer = .init(repeating: 0, count: 30)",
      "    }",
      "",
      "    mutating func put(_ x: UInt8) {",
      "        if index == bufferSize {",
      "            FileHandle.standardOutput.write(Data(data))",
      "            index = 0",
      "        }",
      "        data[index] = x",
      "        index += 1",
      "    }",
      "",
      "    mutating func flush() {",
      "        FileHandle.standardOutput.write(Data(data[0 ..< index]))",
      "        index = 0",
      "    }",
      "",
      "    mutating func print(_ x: Character) {",
      "        put(x.asciiValue!)",
      "    }",
      "",
      "    mutating func print(_ x: Int) {",
      "        if x < 0 {",
      "            put((\"-\" as Character).asciiValue!)",
      "            self.print(-x)",
      "            return",
      "        }",
      "        if x == 0 {",
      "            put((\"0\" as Character).asciiValue!)",
      "            return",
      "        }",
      "        var k = 30",
      "        var x = x",
      "        while x > 0 {",
      "            k -= 1",
      "            intBuffer[k] = UInt8(x % 10)",
      "            x \/= 10",
      "        }",
      "        for x in intBuffer[k...] {",
      "            put((\"0\" as Character).asciiValue! + x)",
      "        }",
      "    }",
      "",
      "    mutating func printSpace() {",
      "        put((\" \" as Character).asciiValue!)",
      "    }",
      "",
      "    mutating func println() {",
      "        put((\"\\n\" as Character).asciiValue!)",
      "    }",
      "}",
      "",
      "struct Scanner {",
      "    private let bufferSize = 4096 * 4",
      "    private var data = [UInt8]()",
      "    private var index: Int = 0",
      "",
      "    mutating func peek() -> UInt8 {",
      "        if index == data.count {",
      "            data = Array(FileHandle.standardInput.readData(ofLength: bufferSize))",
      "            index = 0",
      "        }",
      "        return data[index]",
      "    }",
      "",
      "    mutating func skip() {",
      "        index += 1",
      "    }",
      "",
      "    mutating func read() -> UInt8 {",
      "        defer { skip() }",
      "        return peek()",
      "    }",
      "",
      "    private mutating func isSpace() -> Bool {",
      "        let x = peek()",
      "        return x == (\" \" as Character).asciiValue! || x == (\"\\n\" as Character).asciiValue!",
      "    }",
      "",
      "    private mutating func isDigit() -> Bool {",
      "        let x = peek()",
      "        return (\"0\" as Character).asciiValue! <= x && x <= (\"9\" as Character).asciiValue!",
      "    }",
      "",
      "    mutating func nextBytes() -> [UInt8] {",
      "        var result = [UInt8]()",
      "        while isSpace() {",
      "            skip()",
      "        }",
      "        while !isSpace() {",
      "            result.append(read())",
      "        }",
      "        return result",
      "    }",
      "",
      "    mutating func next() -> String {",
      "        String(bytes: nextBytes(), encoding: .utf8)!",
      "    }",
      "",
      "    mutating func nextInt() -> Int {",
      "        var result = 0",
      "        while isSpace() {",
      "            skip()",
      "        }",
      "        var negative: Bool = false",
      "        if peek() == (\"-\" as Character).asciiValue! {",
      "            negative = true",
      "            skip()",
      "        }",
      "        while isDigit() {",
      "            result = result * 10 + Int(read() - (\"0\" as Character).asciiValue!)",
      "        }",
      "        if negative {",
      "            result = -result",
      "        }",
      "        return result",
      "    }",
      "}",
      ""
    ]
  },
  "Convex Hull" : {
    "prefix" : "myconvexhull",
    "description" : "",
    "body" : [
      "func convexHull(_ points: [Point]) -> [Point] {",
      "    if points.count <= 2 {",
      "        return points",
      "    }",
      "    let points = points.sorted { lhs, rhs in",
      "        return (lhs.x, lhs.y) < (rhs.x, rhs.y)",
      "    }",
      "    var lowerHull = [Point]()",
      "    for point in points {",
      "        while lowerHull.count >= 2 && (lowerHull[lowerHull.count - 1] - lowerHull[lowerHull.count - 2]).cross(point - lowerHull[lowerHull.count - 1]) <= 0 {",
      "            lowerHull.removeLast()",
      "        }",
      "        lowerHull.append(point)",
      "    }",
      "    var upperHull = [Point]()",
      "    for point in points.reversed() {",
      "        while upperHull.count >= 2 && (upperHull[upperHull.count - 1] - upperHull[upperHull.count - 2]).cross(point - upperHull[upperHull.count - 1]) <= 0 {",
      "            upperHull.removeLast()",
      "        }",
      "        upperHull.append(point)",
      "    }",
      "    lowerHull.removeLast()",
      "    upperHull.removeLast()",
      "    return lowerHull + upperHull",
      "}",
      ""
    ]
  },
  "Prefix Sum" : {
    "prefix" : "myprefixsum",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 1acf278d-e34b-4da1-b1d5-bf0a4fec83aa",
      "extension Collection where Element: AdditiveArithmetic {",
      "    \/\/\/ 累積和",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ assert([].prefixSum() == [0])",
      "    \/\/\/ assert([1, 2, 3, 4, 5].prefixSum() == [0, 1, 3, 6, 10, 15])",
      "    \/\/\/ ```",
      "    func prefixSum() -> [Element] {",
      "        var result: [Element] = [.zero]",
      "        for element in self {",
      "            result.append(result.last! + element)",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testPrefixSum() {",
      "    assert([].prefixSum() == [0])",
      "    assert([1, 2, 3, 4, 5].prefixSum() == [0, 1, 3, 6, 10, 15])",
      "}",
      "",
      "testPrefixSum()",
      ""
    ]
  },
  "Red Black Tree" : {
    "prefix" : "mytreemap",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 0198c9af-f76c-4aa7-910f-f41fef11bfb8",
      "\/\/ # red black tree",
      "\/\/",
      "\/\/ ## references",
      "\/\/ - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. Introduction to Algorithms, The MIT Press, third edition, 2009.",
      "class TreeMap<Key: Comparable, Value> {",
      "    private enum Color {",
      "        case red",
      "        case black",
      "    }",
      "",
      "    private class Node {",
      "        var key: Key",
      "        var value: Value",
      "        var left: Node?",
      "        var right: Node?",
      "        var color: Color",
      "",
      "        init(key: Key, value: Value) {",
      "            self.key = key",
      "            self.value = value",
      "            self.color = .red",
      "        }",
      "    }",
      "",
      "    private var root: Node?",
      "",
      "    init() {",
      "    }",
      "",
      "    private func rotateLeft(_ x: Node) -> Node {",
      "        let y = x.right!",
      "        x.right = y.left",
      "        y.left = x",
      "        return y",
      "    }",
      "",
      "    private func rotateRight(_ x: Node) -> Node {",
      "        let y = x.left!",
      "        x.left = y.right",
      "        y.right = x",
      "        return y",
      "    }",
      "",
      "    private func violates(_ x: Node?) -> Bool {",
      "        x?.color == .red && (x?.left?.color == .red || x?.right?.color == .red)",
      "    }",
      "",
      "    func contains(key: Key) -> Bool {",
      "        func contains(_ x: Node?) -> Bool {",
      "            guard let x = x else { return false }",
      "            if key == x.key {",
      "                return true",
      "            }",
      "            if key < x.key {",
      "                return contains(x.left)",
      "            } else {",
      "                return contains(x.right)",
      "            }",
      "        }",
      "        return contains(root)",
      "    }",
      "",
      "    func find(key: Key) -> Value? {",
      "        func find(_ x: Node?) -> Node? {",
      "            guard let x = x else { return nil }",
      "            if key == x.key {",
      "                return x",
      "            }",
      "            if key < x.key {",
      "                return find(x.left)",
      "            } else {",
      "                return find(x.right)",
      "            }",
      "        }",
      "        return find(root)?.value",
      "    }",
      "",
      "    subscript(key: Key) -> Value? {",
      "        get {",
      "            find(key: key)",
      "        }",
      "        set {",
      "            if let newValue = newValue {",
      "                insert(key: key, value: newValue)",
      "            } else {",
      "                \/\/ erase element",
      "            }",
      "        }",
      "    }",
      "",
      "    func insert(key: Key, value: Value) {",
      "        func insert(_ x: Node?) -> Node {",
      "            guard var x = x else { return Node(key: key, value: value) }",
      "            if key == x.key {",
      "                x.value = value",
      "                return x",
      "            }",
      "            if key < x.key {",
      "                x.left = insert(x.left)",
      "                if violates(x.left) {",
      "                    if x.right?.color == .red {",
      "                        x.color = .red",
      "                        x.left?.color = .black",
      "                        x.right?.color = .black",
      "                    } else {",
      "                        if x.left?.right?.color == .red {",
      "                            x.left = rotateLeft(x.left!)",
      "                        }",
      "                        x.left?.color = .black",
      "                        x.color = .red",
      "                        x = rotateRight(x)",
      "                    }",
      "                }",
      "            } else {",
      "                x.right = insert(x.right)",
      "                if violates(x.right) {",
      "                    if x.left?.color == .red {",
      "                        x.color = .red",
      "                        x.right?.color = .black",
      "                        x.left?.color = .black",
      "                    } else {",
      "                        if x.right?.left?.color == .red {",
      "                            x.right = rotateRight(x.right!)",
      "                        }",
      "                        x.right?.color = .black",
      "                        x.color = .red",
      "                        x = rotateLeft(x)",
      "                    }",
      "                }",
      "            }",
      "            return x",
      "        }",
      "        root = insert(root)",
      "        root?.color = .black",
      "    }",
      "",
      "    func findKey(lessThan key: Key) -> Key? {",
      "        func f(_ x: Node?) -> Key? {",
      "            guard let x = x else { return nil }",
      "            if key <= x.key {",
      "                return f(x.left)",
      "            } else {",
      "                if let returned = f(x.right) {",
      "                    return returned",
      "                } else {",
      "                    return x.key",
      "                }",
      "            }",
      "        }",
      "        return f(root)",
      "    }",
      "",
      "    func findKey(greaterThan key: Key) -> Key? {",
      "        func f(_ x: Node?) -> Key? {",
      "            guard let x = x else { return nil }",
      "            if key >= x.key {",
      "                return f(x.right)",
      "            } else {",
      "                if let returned = f(x.left) {",
      "                    return returned",
      "                } else {",
      "                    return x.key",
      "                }",
      "            }",
      "        }",
      "        return f(root)",
      "    }",
      "}"
    ]
  },
  "Xor Bases" : {
    "prefix" : "myxorbases",
    "description" : "",
    "body" : [
      "struct XorBases {",
      "    var bases: [Int] = []",
      "",
      "    mutating func insert(_ x: Int) {",
      "        var x = x",
      "        for y in bases {",
      "            x = min(x, x ^ y)",
      "        }",
      "        if x != 0 {",
      "            bases.append(x)",
      "        }",
      "    }",
      "",
      "    mutating func contains(_ x: Int) -> Bool {",
      "        var x = x",
      "        for y in bases {",
      "            x = min(x, x ^ y)",
      "        }",
      "        return x == 0",
      "    }",
      "}"
    ]
  },
  "Prime Factorization" : {
    "prefix" : "myprimefactors",
    "description" : "",
    "body" : [
      "extension Int {",
      "    \/\/\/ ```",
      "    \/\/\/ assert(1.primeFactors() == [:])",
      "    \/\/\/ assert(12.primeFactors() == [2: 2, 3: 1])",
      "    \/\/\/ assert(60.primeFactors() == [2: 2, 3: 1, 5: 1])",
      "    \/\/\/ ```",
      "    func primeFactors() -> [Int: Int] {",
      "        precondition(self >= 1)",
      "        var result = [Int: Int]()",
      "        var n = self",
      "        var i = 2",
      "        while i * i <= n {",
      "            if n % i == 0 {",
      "                var count = 0",
      "                while n % i == 0 {",
      "                    n \/= i",
      "                    count += 1",
      "                }",
      "                result[i] = count",
      "            }",
      "            i += 1",
      "        }",
      "        if n > 1 {",
      "            result[n] = 1",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testPrimeFactors() {",
      "    assert(1.primeFactors() == [:])",
      "    assert(2.primeFactors() == [2: 1])",
      "    assert(3.primeFactors() == [3: 1])",
      "    assert(4.primeFactors() == [2: 2])",
      "    assert(5.primeFactors() == [5: 1])",
      "    assert(6.primeFactors() == [2: 1, 3: 1])",
      "    assert(7.primeFactors() == [7: 1])",
      "    assert(8.primeFactors() == [2: 3])",
      "    assert(9.primeFactors() == [3: 2])",
      "    assert(10.primeFactors() == [2: 1, 5: 1])",
      "    assert(11.primeFactors() == [11: 1])",
      "    assert(12.primeFactors() == [2: 2, 3: 1])",
      "    assert(36.primeFactors() == [2: 2, 3: 2])",
      "    assert(60.primeFactors() == [2: 2, 3: 1, 5: 1])",
      "}",
      "",
      "testPrimeFactors()",
      ""
    ]
  },
  "Queue" : {
    "prefix" : "myqueue",
    "description" : "",
    "body" : [
      "struct Queue<Element> {",
      "    private var deque = Deque<Element>()",
      "",
      "    mutating func enqueue(_ newElement: Element) {",
      "        deque.pushBack(newElement)",
      "    }",
      "",
      "    mutating func dequeue() -> Element? {",
      "        deque.popFront()",
      "    }",
      "}"
    ]
  },
  "Zn" : {
    "prefix" : "myzn",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 5b2dba67-1136-4a0d-84db-d86dc3e7ed7d",
      "let mod = 1000000007",
      "\/\/ let mod = 998244353",
      "",
      "struct Zn: CustomStringConvertible, AdditiveArithmetic, Hashable, ExpressibleByIntegerLiteral {",
      "    typealias IntegerLiteralType = Int",
      "",
      "    let n: Int",
      "",
      "    init(_ n: Int) {",
      "        self.n = n",
      "    }",
      "",
      "    init(safe n: Int) {",
      "        let m = n % mod",
      "        if m >= 0 {",
      "            self.n = m",
      "        } else {",
      "            self.n = m + mod",
      "        }",
      "    }",
      "",
      "    init(integerLiteral value: IntegerLiteralType) {",
      "        self.n = value",
      "    }",
      "",
      "    var description: String {",
      "        String(self.n)",
      "    }",
      "",
      "    static var zero = Zn(0)",
      "    static var one = Zn(1)",
      "",
      "    static prefix func - (value: Self) -> Self {",
      "        return Zn(value.n == 0 ? 0 : mod - value.n)",
      "    }",
      "",
      "    static func + (lhs: Self, rhs: Self) -> Self {",
      "        let n = lhs.n + rhs.n",
      "        return Zn(n < mod ? n : n - mod)",
      "    }",
      "",
      "    static func + (lhs: Self, rhs: Int) -> Self {",
      "        return lhs + Zn(rhs)",
      "    }",
      "",
      "    static func + (lhs: Int, rhs: Self) -> Self {",
      "        return Zn(lhs) + rhs",
      "    }",
      "",
      "    static func - (lhs: Self, rhs: Self) -> Self {",
      "        let n = lhs.n - rhs.n",
      "        return Zn(n >= 0 ? n : n + mod)",
      "    }",
      "",
      "    static func - (lhs: Self, rhs: Int) -> Self {",
      "        return lhs - Zn(rhs)",
      "    }",
      "",
      "    static func - (lhs: Int, rhs: Self) -> Self {",
      "        return Zn(lhs) - rhs",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Self) -> Self {",
      "        Zn((lhs.n * rhs.n) % mod)",
      "    }",
      "",
      "    static func * (lhs: Self, rhs: Int) -> Self {",
      "        return lhs * Zn(rhs)",
      "    }",
      "",
      "    static func * (lhs: Int, rhs: Self) -> Self {",
      "        return Zn(lhs) * rhs",
      "    }",
      "",
      "    static func \/ (lhs: Zn, rhs: Zn) -> Self {",
      "        return lhs * rhs.inverse",
      "    }",
      "",
      "    static func \/ (lhs: Int, rhs: Zn) -> Self {",
      "        return Zn(lhs) * rhs.inverse",
      "    }",
      "",
      "    static func \/ (lhs: Zn, rhs: Int) -> Self {",
      "        return lhs * Zn(rhs).inverse",
      "    }",
      "",
      "    static func += (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs + rhs",
      "    }",
      "",
      "    static func += (lhs: inout Self, rhs: Int) {",
      "        lhs = lhs + Zn(rhs)",
      "    }",
      "",
      "    static func -= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs - rhs",
      "    }",
      "",
      "    static func -= (lhs: inout Self, rhs: Int) {",
      "        lhs = lhs - Zn(rhs)",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs * rhs",
      "    }",
      "",
      "    static func *= (lhs: inout Self, rhs: Int) {",
      "        lhs = lhs * Zn(rhs)",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Self) {",
      "        lhs = lhs \/ rhs",
      "    }",
      "",
      "    static func \/= (lhs: inout Self, rhs: Int) {",
      "        lhs = lhs \/ Zn(rhs)",
      "    }",
      "",
      "    static func ** (lhs: Self, rhs: Int) -> Self {",
      "        lhs.pow(rhs)",
      "    }",
      "",
      "    func pow(_ n: Int) -> Self {",
      "        if n < 0 {",
      "            return inverse.pow(-n)",
      "        }",
      "        var result: Zn = 1",
      "        var x: Zn = self",
      "        var n = n",
      "        while n > 0 {",
      "            if n & 1 == 1 {",
      "                result *= x",
      "            }",
      "            x *= x",
      "            n >>= 1",
      "        }",
      "        return result",
      "    }",
      "",
      "    var inverse: Self {",
      "        self.pow(mod - 2)",
      "    }",
      "}",
      "",
      "func testZn() {",
      "    \/\/\/ 0除算を回避するため",
      "    if mod < 100 {",
      "        return",
      "    }",
      "",
      "    func testNegation() {",
      "        assert(-Zn(safe: 5) == Zn(safe: -5))",
      "        assert(-Zn(safe: 0) == 0)",
      "    }",
      "",
      "    func testAddition() {",
      "        assert((Zn(safe: 3) + Zn(safe: 5)).n == Zn(safe: 8).n)",
      "        assert((Zn(safe: 5) + Zn(safe: -4)).n == Zn(safe: 1).n)",
      "    }",
      "",
      "    func testSubtraction() {",
      "        assert(Zn(safe: 5) - Zn(safe: 3) == Zn(safe: 2))",
      "        assert(Zn(safe: 3) - Zn(safe: 5) == Zn(safe: -2))",
      "        assert(Zn(safe: 3) - Zn(safe: 3) == Zn(safe: 0))",
      "    }",
      "",
      "    func testMultiplication() {",
      "        assert(Zn(safe: 3) * Zn(safe: 4) == Zn(safe: 12))",
      "        assert(Zn(safe: 3) * Zn(safe: -4) == Zn(safe: -12))",
      "        assert(Zn(safe: -3) * Zn(safe: 4) == Zn(safe: -12))",
      "        assert(Zn(safe: -3) * Zn(safe: -4) == Zn(safe: 12))",
      "        assert(Zn(safe: 3) * Zn(safe: 0) == Zn(safe: 0))",
      "        assert(Zn(safe: 0) * Zn(safe: 3) == Zn(safe: 0))",
      "        assert(Zn(safe: 0) * Zn(safe: 0) == Zn(safe: 0))",
      "    }",
      "",
      "    func testDivision() {",
      "        assert(Zn(safe: 3) \/ Zn(safe: 2) * Zn(safe: 2) == Zn(safe: 3))",
      "        assert(Zn(safe: 3) \/ Zn(safe: -2) * Zn(safe: -2) == Zn(safe: 3))",
      "        assert(Zn(safe: 3) \/ Zn(safe: 1) * Zn(safe: 1) == Zn(safe: 3))",
      "        assert(Zn(safe: 3) \/ Zn(safe: -1) * Zn(safe: -1) == Zn(safe: 3))",
      "        assert(Zn(safe: 0) \/ Zn(safe: 3) * Zn(safe: 3) == Zn(safe: 0))",
      "    }",
      "",
      "    func testPower() {",
      "        assert(Zn(safe: 2).pow(0) == Zn(safe: 1))",
      "        assert(Zn(safe: 2).pow(1) == Zn(safe: 2))",
      "        assert(Zn(safe: 2).pow(2) == Zn(safe: 2 * 2))",
      "        assert(Zn(safe: 2).pow(3) == Zn(safe: 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(4) == Zn(safe: 2 * 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(5) == Zn(safe: 2 * 2 * 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(6) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(7) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(8) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2))",
      "        assert(Zn(safe: 2).pow(-1) == Zn(safe: 2).inverse)",
      "        assert(Zn(safe: 2).pow(-2) == Zn(safe: 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-3) == Zn(safe: 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-4) == Zn(safe: 2 * 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-5) == Zn(safe: 2 * 2 * 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-6) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-7) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 2).pow(-8) == Zn(safe: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2).inverse)",
      "        assert(Zn(safe: 3).pow(0) == Zn(safe: 1))",
      "        assert(Zn(safe: 3).pow(1) == Zn(safe: 3))",
      "        assert(Zn(safe: 3).pow(2) == Zn(safe: 3 * 3))",
      "        assert(Zn(safe: 3).pow(3) == Zn(safe: 3 * 3 * 3))",
      "        assert(Zn(safe: 3).pow(4) == Zn(safe: 3 * 3 * 3 * 3))",
      "        assert(Zn(safe: 3).pow(5) == Zn(safe: 3 * 3 * 3 * 3 * 3))",
      "        assert(Zn(safe: 3).pow(6) == Zn(safe: 3 * 3 * 3 * 3 * 3 * 3))",
      "        assert(Zn(safe: 3).pow(7) == Zn(safe: 3 * 3 * 3 * 3 * 3 * 3 * 3))",
      "        assert(Zn(safe: 3).pow(8) == Zn(safe: 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3))",
      "    }",
      "",
      "    func testInverse() {",
      "        assert(Zn(safe: 1).inverse * Zn(safe: 1) == Zn(safe: 1))",
      "        assert(Zn(safe: 2).inverse * Zn(safe: 2) == Zn(safe: 1))",
      "        assert(Zn(safe: 3).inverse * Zn(safe: 3) == Zn(safe: 1))",
      "        assert(Zn(safe: 4).inverse * Zn(safe: 4) == Zn(safe: 1))",
      "        assert(Zn(safe: 5).inverse * Zn(safe: 5) == Zn(safe: 1))",
      "        assert(Zn(safe: 6).inverse * Zn(safe: 6) == Zn(safe: 1))",
      "        assert(Zn(safe: 7).inverse * Zn(safe: 7) == Zn(safe: 1))",
      "        assert(Zn(safe: 8).inverse * Zn(safe: 8) == Zn(safe: 1))",
      "    }",
      "",
      "    testNegation()",
      "    testAddition()",
      "    testSubtraction()",
      "    testMultiplication()",
      "    testDivision()",
      "    testPower()",
      "    testInverse()",
      "}",
      "",
      "testZn()"
    ]
  },
  "Print AtCoder" : {
    "prefix" : "myprintatcoder",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 7f589b10-6bc0-49b8-9c14-67f010d16ced",
      "func printAtCoder(_ a: [Int], separator: String = \" \", offset: Int = 0) {",
      "    print(a.map { \\$0 + offset }.map(\\.description).joined(separator: separator))",
      "}"
    ]
  },
  "Binary Heap" : {
    "prefix" : "mybinaryheap",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 8fa5965d-76d1-4de3-a76c-0b57a325733a",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct BinaryHeap<Value> {",
      "    private var heap: [Value]",
      "    private var lessThan: (Value, Value) -> Bool",
      "",
      "    init(lessThan: @escaping (Value, Value) -> Bool) {",
      "        self.heap = []",
      "        self.lessThan = lessThan",
      "    }",
      "",
      "    var count: Int {",
      "        heap.count",
      "    }",
      "",
      "    var isEmpty: Bool {",
      "        heap.isEmpty",
      "    }",
      "",
      "    mutating func insert(_ v: Value) {",
      "        var k = heap.count",
      "        heap.append(v)",
      "        while k > 0 {",
      "            let p = (k - 1) \/ 2",
      "            if lessThan(heap[k], heap[p]) {",
      "                heap.swapAt(k, p)",
      "                k = p",
      "            } else {",
      "                break",
      "            }",
      "        }",
      "    }",
      "",
      "    func peekMin() -> Value? {",
      "        heap.first",
      "    }",
      "",
      "    mutating func extractMin() -> Value? {",
      "        guard let result = heap.first else { return nil }",
      "        heap.swapAt(0, heap.endIndex - 1)",
      "        heap.removeLast()",
      "        var k = 0",
      "        while true {",
      "            var l = k",
      "            for c in [k * 2 + 1, k * 2 + 2] where c < heap.count && lessThan(heap[c], heap[l]) {",
      "                l = c",
      "            }",
      "            if k == l {",
      "                break",
      "            }",
      "            heap.swapAt(k, l)",
      "            k = l",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testBinaryHeap() {",
      "    var heap = BinaryHeap<Int>(lessThan: <)",
      "    heap.insert(2)",
      "    heap.insert(1)",
      "    assert(heap.extractMin() == .some(1))",
      "    heap.insert(4)",
      "    heap.insert(3)",
      "    assert(heap.extractMin() == .some(2))",
      "    assert(heap.extractMin() == .some(3))",
      "    assert(heap.extractMin() == .some(4))",
      "    assert(heap.extractMin() == .none)",
      "    heap.insert(5)",
      "    assert(heap.extractMin() == .some(5))",
      "    assert(heap.extractMin() == .none)",
      "}",
      "",
      "testBinaryHeap()",
      "",
      "extension BinaryHeap: Sequence {",
      "    func makeIterator() -> some IteratorProtocol {",
      "        heap.makeIterator()",
      "    }",
      "}"
    ]
  },
  "Binary Indexed Tree" : {
    "prefix" : "mybit",
    "description" : "",
    "body" : [
      "import Foundation",
      "",
      "\/\/ snippet_id: a1cd31a0-4f0e-43ad-ba3f-9dd67501df8c",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct BinaryIndexedTree<Element> where Element: AdditiveArithmetic {",
      "    private var elements: [Element]",
      "",
      "    var count: Int {",
      "        elements.count - 1",
      "    }",
      "",
      "    init(_ n: Int) {",
      "        precondition(n >= 0)",
      "        elements = [Element](repeating: .zero, count: n + 1)",
      "    }",
      "",
      "    subscript(k: Int) -> Element {",
      "        get {",
      "            return sum(k ..< k + 1)",
      "        }",
      "        set {",
      "            let s = self[k]",
      "            add(at: k, .zero - s)",
      "            add(at: k, newValue)",
      "        }",
      "    }",
      "",
      "    mutating func add(at: Int, _ value: Element) {",
      "        precondition((0 ..< count).contains(at))",
      "        var n = at + 1",
      "        while n < elements.count {",
      "            elements[n] += value",
      "            n += n & -n",
      "        }",
      "    }",
      "",
      "    private func sum(_ k: Int) -> Element {",
      "        precondition((0 ... count).contains(k))",
      "        var n = k",
      "        var result = Element.zero",
      "        while n > 0 {",
      "            result += elements[n]",
      "            n -= n & -n",
      "        }",
      "        return result",
      "    }",
      "",
      "    func sum(_ range: Range<Int>) -> Element {",
      "        sum(range.upperBound) - sum(range.lowerBound)",
      "    }",
      "",
      "    func sum<R: RangeExpression>(_ range: R) -> Element where R.Bound == Int {",
      "        sum(range.relative(to: 0 ..< count))",
      "    }",
      "",
      "    func sum(_ range: UnboundedRange) -> Element {",
      "        sum(count)",
      "    }",
      "}",
      "",
      "func testBinaryIndexedTree() {",
      "    func testUpdate() {",
      "        var bit = BinaryIndexedTree<Int>(5)",
      "        bit.add(at: 0, 1) \/\/ [1, 0, 0, 0, 0]",
      "        bit.add(at: 1, 2) \/\/ [1, 2, 0, 0, 0]",
      "        bit.add(at: 2, 3) \/\/ [1, 2, 3, 0, 0]",
      "    }",
      "",
      "    func testSum() {",
      "        var bit = BinaryIndexedTree<Int>(5)",
      "        bit.add(at: 0, 1)",
      "        bit.add(at: 1, 2)",
      "        bit.add(at: 2, 4)",
      "        bit.add(at: 3, 8)",
      "        bit.add(at: 4, 16)",
      "",
      "        assert(bit.sum(...) == 1 + 2 + 4 + 8 + 16)",
      "",
      "        assert(bit.sum(..<0) == 0)",
      "        assert(bit.sum(..<1) == 1)",
      "        assert(bit.sum(..<2) == 1 + 2)",
      "        assert(bit.sum(..<3) == 1 + 2 + 4)",
      "        assert(bit.sum(..<4) == 1 + 2 + 4 + 8)",
      "        assert(bit.sum(..<5) == 1 + 2 + 4 + 8 + 16)",
      "",
      "        assert(bit.sum(...0) == 1)",
      "        assert(bit.sum(...1) == 1 + 2)",
      "        assert(bit.sum(...2) == 1 + 2 + 4)",
      "        assert(bit.sum(...3) == 1 + 2 + 4 + 8)",
      "        assert(bit.sum(...4) == 1 + 2 + 4 + 8 + 16)",
      "",
      "        assert(bit.sum(0...) == 1 + 2 + 4 + 8 + 16)",
      "        assert(bit.sum(1...) == 2 + 4 + 8 + 16)",
      "        assert(bit.sum(2...) == 4 + 8 + 16)",
      "        assert(bit.sum(3...) == 8 + 16)",
      "        assert(bit.sum(4...) == 16)",
      "",
      "        assert(bit.sum(1 ..< 2) == 2)",
      "        assert(bit.sum(1 ..< 3) == 2 + 4)",
      "        assert(bit.sum(1 ..< 4) == 2 + 4 + 8)",
      "        assert(bit.sum(1 ..< 5) == 2 + 4 + 8 + 16)",
      "",
      "        assert(bit.sum(0 ..< 0) == 0)",
      "        assert(bit.sum(1 ..< 1) == 0)",
      "        assert(bit.sum(5 ..< 5) == 0)",
      "",
      "        assert(bit.sum(1 ... 2) == 2 + 4)",
      "        assert(bit.sum(1 ... 3) == 2 + 4 + 8)",
      "        assert(bit.sum(1 ... 4) == 2 + 4 + 8 + 16)",
      "",
      "        assert(bit[0] == 1)",
      "        assert(bit[1] == 2)",
      "        assert(bit[2] == 4)",
      "        assert(bit[3] == 8)",
      "        assert(bit[4] == 16)",
      "",
      "        bit[3] = 32",
      "        assert(bit[0] == 1)",
      "        assert(bit[1] == 2)",
      "        assert(bit[2] == 4)",
      "        assert(bit[3] == 32)",
      "        assert(bit[4] == 16)",
      "    }",
      "",
      "    testUpdate()",
      "    testSum()",
      "}",
      "",
      "testBinaryIndexedTree()"
    ]
  },
  "Combination" : {
    "prefix" : "mycombination",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 052a470b-fac9-4f06-a5a1-e4e42661417a",
      "struct Combination {",
      "    private var factorial: [Zn]",
      "    private var inverseFactorial: [Zn]",
      "    private var inverse: [Zn]",
      "",
      "    init() {",
      "        factorial = [1, 1]",
      "        inverseFactorial = [1, 1]",
      "        inverse = [0, 1]",
      "    }",
      "",
      "    private mutating func stretch(through: Int) {",
      "        while factorial.count <= through {",
      "            let k = factorial.count",
      "            factorial.append(factorial[k - 1] * k)",
      "            inverse.append(inverse[mod % k] * (mod - mod \/ k))",
      "            inverseFactorial.append(inverseFactorial[k - 1] * inverse[k])",
      "        }",
      "    }",
      "",
      "    \/\/\/ `n`の階乗",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.factorial(0) == 1)",
      "    \/\/\/ assert(combination.factorial(1) == 1)",
      "    \/\/\/ assert(combination.factorial(2) == 2)",
      "    \/\/\/ assert(combination.factorial(3) == 6)",
      "    \/\/\/ assert(combination.factorial(4) == 24)",
      "    \/\/\/ assert(combination.factorial(5) == 120)",
      "    \/\/\/ ```",
      "    mutating func factorial(_ n: Int) -> Zn {",
      "        precondition(n >= 0)",
      "        stretch(through: n)",
      "        return self.factorial[n]",
      "    }",
      "",
      "    \/\/\/ `n`の階乗の逆元",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.inverseFactorial(10) * combination.factorial(10) == 1)",
      "    \/\/\/ ```",
      "    mutating func inverseFactorial(_ n: Int) -> Zn {",
      "        precondition(n >= 0)",
      "        stretch(through: n)",
      "        return self.inverseFactorial[n]",
      "    }",
      "",
      "    \/\/\/ `n`の逆元",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.inverse(5) * 5 == 1)",
      "    \/\/\/ assert(combination.inverse(-5) * -Zn(5) == 1)",
      "    \/\/\/ ```",
      "    mutating func inverse(_ n: Int) -> Zn {",
      "        precondition(n != 0)",
      "        if n < 0 {",
      "            return -inverse(-n)",
      "        }",
      "        stretch(through: n)",
      "        return self.inverse[n]",
      "    }",
      "",
      "    \/\/\/ `n`個から`r`個取る順列の総数",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.P(5, 3) == 5 * 4 * 3)",
      "    \/\/\/ assert(combination.P(1, 2) == 0)",
      "    \/\/\/ assert(combination.P(0, 0) == 1)",
      "    \/\/\/ assert(combination.P(-1, 0) == 0)",
      "    \/\/\/ assert(combination.P(0, -1) == 0)",
      "    \/\/\/ assert(combination.P(-1, -1) == 0)",
      "    \/\/\/ ```",
      "    mutating func P(_ n: Int, _ r: Int) -> Zn {",
      "        guard n >= 0 && r >= 0 && n >= r else { return 0 }",
      "        return self.factorial(n) * self.inverseFactorial(n - r)",
      "    }",
      "",
      "    \/\/\/ `n`個から`r`個取る組合せの総数",
      "    \/\/\/ `(1+x)^n`の`x^r`の係数",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.C(5, 3) == 5 * 4 * 3 \/ (3 * 2 * 1))",
      "    \/\/\/ assert(combination.C(1, 2) == 0)",
      "    \/\/\/ assert(combination.C(0, 0) == 1)",
      "    \/\/\/ assert(combination.C(-1, 0) == 0)",
      "    \/\/\/ assert(combination.C(0, -1) == 0)",
      "    \/\/\/ assert(combination.C(-1, -1) == 0)",
      "    \/\/\/ ```",
      "    mutating func C(_ n: Int, _ r: Int) -> Zn {",
      "        if r < 0 {",
      "            return 0",
      "        }",
      "        if n >= 0 {",
      "            if n < r {",
      "                return 0",
      "            } else {",
      "                return self.factorial(n) * self.inverseFactorial(n - r) * self.inverseFactorial(r)",
      "            }",
      "        } else {",
      "            if r % 2 == 0 {",
      "                return H(-n, r)",
      "            } else {",
      "                return -H(-n, r)",
      "            }",
      "        }",
      "    }",
      "",
      "    \/\/\/ `n`個から`r`個取る重複組合せの総数",
      "    \/\/\/ `1\/(1-x)^n`の`x^r`の係数",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var combination = Combination()",
      "    \/\/\/ assert(combination.H(5, 3) == 5 * 6 * 7 \/ (3 * 2 * 1))",
      "    \/\/\/ assert(combination.H(1, 2) == 1 * 2 \/ (2 * 1))",
      "    \/\/\/ assert(combination.H(0, 0) == 1)",
      "    \/\/\/ assert(combination.H(-1, 0) == 0)",
      "    \/\/\/ assert(combination.H(0, -1) == 0)",
      "    \/\/\/ assert(combination.H(-1, -1) == 0)",
      "    \/\/\/ ```",
      "    mutating func H(_ n: Int, _ r: Int) -> Zn {",
      "        if r < 0 {",
      "            return 0",
      "        }",
      "        if n > 0 {",
      "            return factorial(n + r - 1) * inverseFactorial(n - 1) * inverseFactorial(r)",
      "        } else {",
      "            if r % 2 == 0 {",
      "                return C(-n, r)",
      "            } else {",
      "                return -C(-n, r)",
      "            }",
      "        }",
      "    }",
      "}",
      "",
      "\/\/ TODO: nCrとnHrにおいてnが負の場合のテストを書く",
      "func testCombination() {",
      "    if mod < 100 {",
      "        return",
      "    }",
      "",
      "    func testFactorial() {",
      "        var combination = Combination()",
      "        assert(combination.factorial(0) == 1)",
      "        assert(combination.factorial(1) == 1)",
      "        assert(combination.factorial(2) == 2)",
      "        assert(combination.factorial(3) == 6)",
      "        assert(combination.factorial(4) == 24)",
      "        assert(combination.factorial(5) == 120)",
      "    }",
      "",
      "    func testInverseFactorial() {",
      "        var combination = Combination()",
      "        assert(combination.inverseFactorial(10) * combination.factorial(10) == 1)",
      "    }",
      "",
      "    func testInverse() {",
      "        var combination = Combination()",
      "        assert(combination.inverse(5) * 5 == 1)",
      "        assert(combination.inverse(-5) * -Zn(5) == 1)",
      "    }",
      "",
      "    func testP() {",
      "        var combination = Combination()",
      "        assert(combination.P(5, 3) == Zn(5) * Zn(4) * Zn(3))",
      "        assert(combination.P(1, 2) == 0)",
      "        assert(combination.P(0, 0) == 1)",
      "        assert(combination.P(-1, 0) == 0)",
      "        assert(combination.P(0, -1) == 0)",
      "        assert(combination.P(-1, -1) == 0)",
      "    }",
      "",
      "    func testC() {",
      "        var combination = Combination()",
      "        assert(combination.C(5, 3) == Zn(5) * Zn(4) * Zn(3) \/ (Zn(3) * Zn(2) * Zn(1)))",
      "        assert(combination.C(1, 2) == 0)",
      "        assert(combination.C(0, 0) == 1)",
      "        assert(combination.C(0, -1) == 0)",
      "    }",
      "",
      "    func testH() {",
      "        var combination = Combination()",
      "        assert(combination.H(5, 3) == Zn(5) * Zn(6) * Zn(7) \/ (Zn(3) * Zn(2) * Zn(1)))",
      "        assert(combination.H(1, 2) == Zn(1) * Zn(2) \/ (Zn(2) * Zn(1)))",
      "        assert(combination.H(0, 0) == 1)",
      "        assert(combination.H(0, -1) == 0)",
      "    }",
      "",
      "    testFactorial()",
      "    testInverseFactorial()",
      "    testInverse()",
      "    testP()",
      "    testC()",
      "    testH()",
      "}",
      "",
      "testCombination()"
    ]
  },
  "Tree Map" : {
    "prefix" : "mytreemap",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: f416ade0-91ea-4a58-adae-2b05bac173da",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "protocol BinarySearchTreeNode {",
      "    associatedtype Node: BinarySearchTreeNode",
      "    associatedtype Key: Comparable",
      "    associatedtype Value",
      "    var left: Node? { get }",
      "    var right: Node? { get }",
      "    var key: Key { get }",
      "    var value: Value { get }",
      "}",
      "",
      "protocol BinarySearchTree {",
      "    associatedtype Node: BinarySearchTreeNode where Node.Node == Node",
      "    var root: Node? { get }",
      "}",
      "",
      "extension BinarySearchTree {",
      "    func contains(key: Node.Key) -> Bool {",
      "        func contains(_ x: Node?) -> Bool {",
      "            guard let x = x else { return false }",
      "            if key == x.key {",
      "                return true",
      "            }",
      "            if key < x.key {",
      "                return contains(x.left)",
      "            } else {",
      "                return contains(x.right)",
      "            }",
      "        }",
      "        return contains(root)",
      "    }",
      "",
      "    func find(key: Node.Key) -> Node.Value? {",
      "        func find(_ x: Node?) -> Node? {",
      "            guard let x = x else { return nil }",
      "            if key == x.key {",
      "                return x",
      "            }",
      "            if key < x.key {",
      "                return find(x.left)",
      "            } else {",
      "                return find(x.right)",
      "            }",
      "        }",
      "        return find(root)?.value",
      "    }",
      "",
      "    func findKey(lessThan key: Node.Key) -> Node.Key? {",
      "        func f(_ x: Node?) -> Node.Key? {",
      "            guard let x = x else { return nil }",
      "            if key <= x.key {",
      "                return f(x.left)",
      "            } else {",
      "                if let returned = f(x.right) {",
      "                    return returned",
      "                } else {",
      "                    return x.key",
      "                }",
      "            }",
      "        }",
      "        return f(root)",
      "    }",
      "",
      "    func findKey(greaterThan key: Node.Key) -> Node.Key? {",
      "        func f(_ x: Node?) -> Node.Key? {",
      "            guard let x = x else { return nil }",
      "            if key >= x.key {",
      "                return f(x.right)",
      "            } else {",
      "                if let returned = f(x.left) {",
      "                    return returned",
      "                } else {",
      "                    return x.key",
      "                }",
      "            }",
      "        }",
      "        return f(root)",
      "    }",
      "}",
      "",
      "\/\/ ## references",
      "\/\/ - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. Introduction to Algorithms, The MIT Press, third edition, 2009.",
      "class RedBlackTreeMap<Key: Comparable, Value>: BinarySearchTree {",
      "    enum Color {",
      "        case red",
      "        case black",
      "    }",
      "",
      "    class Node: BinarySearchTreeNode {",
      "        var key: Key",
      "        var value: Value",
      "        var left: Node?",
      "        var right: Node?",
      "        var color: Color",
      "",
      "        init(key: Key, value: Value) {",
      "            self.key = key",
      "            self.value = value",
      "            self.color = .red",
      "        }",
      "    }",
      "",
      "    var root: Node?",
      "",
      "    init() {",
      "    }",
      "",
      "    private func rotateLeft(_ x: Node) -> Node {",
      "        let y = x.right!",
      "        x.right = y.left",
      "        y.left = x",
      "        return y",
      "    }",
      "",
      "    private func rotateRight(_ x: Node) -> Node {",
      "        let y = x.left!",
      "        x.left = y.right",
      "        y.right = x",
      "        return y",
      "    }",
      "",
      "    private func violates(_ x: Node?) -> Bool {",
      "        x?.color == .red && (x?.left?.color == .red || x?.right?.color == .red)",
      "    }",
      "",
      "    subscript(key: Key) -> Value? {",
      "        get {",
      "            find(key: key)",
      "        }",
      "        set {",
      "            if let newValue = newValue {",
      "                insert(key: key, value: newValue)",
      "            } else {",
      "                \/\/ erase element",
      "            }",
      "        }",
      "    }",
      "",
      "    func insert(key: Key, value: Value) {",
      "        func insert(_ x: Node?) -> Node {",
      "            guard var x = x else { return Node(key: key, value: value) }",
      "            if key == x.key {",
      "                x.value = value",
      "                return x",
      "            }",
      "            if key < x.key {",
      "                x.left = insert(x.left)",
      "                if violates(x.left) {",
      "                    if x.right?.color == .red {",
      "                        x.color = .red",
      "                        x.left?.color = .black",
      "                        x.right?.color = .black",
      "                    } else {",
      "                        if x.left?.right?.color == .red {",
      "                            x.left = rotateLeft(x.left!)",
      "                        }",
      "                        x.left?.color = .black",
      "                        x.color = .red",
      "                        x = rotateRight(x)",
      "                    }",
      "                }",
      "            } else {",
      "                x.right = insert(x.right)",
      "                if violates(x.right) {",
      "                    if x.left?.color == .red {",
      "                        x.color = .red",
      "                        x.right?.color = .black",
      "                        x.left?.color = .black",
      "                    } else {",
      "                        if x.right?.left?.color == .red {",
      "                            x.right = rotateRight(x.right!)",
      "                        }",
      "                        x.right?.color = .black",
      "                        x.color = .red",
      "                        x = rotateLeft(x)",
      "                    }",
      "                }",
      "            }",
      "            return x",
      "        }",
      "        root = insert(root)",
      "        root?.color = .black",
      "    }",
      "}",
      "",
      "",
      "class TreapMap<Key, Value>: BinarySearchTree where Key: Comparable {",
      "    class Node: BinarySearchTreeNode {",
      "        var left: Node?",
      "        var right: Node?",
      "        var priority: Int",
      "        var key: Key",
      "        var value: Value",
      "",
      "        init(key: Key, value: Value) {",
      "            self.key = key",
      "            self.value = value",
      "            self.left = nil",
      "            self.right = nil",
      "            self.priority = Int.random(in: Int.min ... Int.max)",
      "        }",
      "    }",
      "",
      "    var root: Node?",
      "",
      "    private static func rotateLeft(_ x: Node) -> Node {",
      "        let y = x.right!",
      "        x.right = y.left",
      "        y.left = x",
      "        return y",
      "    }",
      "",
      "    private static func rotateRight(_ x: Node) -> Node {",
      "        let y = x.left!",
      "        x.left = y.right",
      "        y.right = x",
      "        return y",
      "    }",
      "",
      "    func insert(key: Key, value: Value) {",
      "        func insert(_ x: Node?) -> Node {",
      "            guard var x = x else {",
      "                return Node(key: key, value: value)",
      "            }",
      "            if key == x.key {",
      "                x.value = value",
      "            } else if key < x.key {",
      "                x.left = insert(x.left)",
      "                if x.left!.priority < x.priority {",
      "                    x = Self.rotateRight(x)",
      "                }",
      "            } else {",
      "                x.right = insert(x.right)",
      "                if x.right!.priority < x.priority {",
      "                    x = Self.rotateLeft(x)",
      "                }",
      "            }",
      "            return x",
      "        }",
      "        self.root = insert(self.root)",
      "    }",
      "",
      "    func remove(key: Key) {",
      "        func remove(_ x: Node?) -> Node? {",
      "            guard let x = x else {",
      "                return nil",
      "            }",
      "            if key == x.key {",
      "                func eliminate(_ x: Node) -> Node? {",
      "                    guard let left = x.left else {",
      "                        return x.right",
      "                    }",
      "                    guard let right = x.right else {",
      "                        return x.left",
      "                    }",
      "                    if left.priority < right.priority {",
      "                        let x = Self.rotateRight(x)",
      "                        x.right = eliminate(x.right!)",
      "                        return x",
      "                    } else {",
      "                        let x = Self.rotateLeft(x)",
      "                        x.left = eliminate(x.left!)",
      "                        return x",
      "                    }",
      "                }",
      "                return eliminate(x)",
      "            } else if key < x.key {",
      "                x.left = remove(x.left)",
      "                return x",
      "            } else {",
      "                x.right = remove(x.right)",
      "                return x",
      "            }",
      "        }",
      "        self.root = remove(self.root)",
      "    }",
      "}",
      ""
    ]
  },
  "RMQmax" : {
    "prefix" : "myrmqmax",
    "description" : "",
    "body" : [
      "struct RMQmax {",
      "    private var nodes: [Int]",
      "    private var size: Int",
      "",
      "    init(_ n: Int) {",
      "        var m = 1",
      "        while m < n {",
      "            m *= 2",
      "        }",
      "        size = m",
      "        nodes = .init(repeating: Int.min, count: m * 2)",
      "    }",
      "",
      "    mutating func update(_ k: Int, _ value: Int) {",
      "        var k = k + size - 1",
      "        nodes[k] = value",
      "        while k > 0 {",
      "            k = (k - 1) \/ 2",
      "            nodes[k] = max(nodes[k * 2 + 1], nodes[k * 2 + 2])",
      "        }",
      "    }",
      "",
      "    func query(_ a: Int, _ b: Int) -> Int {",
      "        func f(_ k: Int, _ l: Int, _ r: Int) -> Int {",
      "            if a <= l && r <= b {",
      "                return nodes[k]",
      "            }",
      "            if r <= a || b <= l {",
      "                return Int.min",
      "            }",
      "            let vl = f(k * 2 + 1, l, (l + r) \/ 2)",
      "            let vr = f(k * 2 + 2, (l + r) \/ 2, r)",
      "            return max(vl, vr)",
      "        }",
      "        return f(0, 0, size)",
      "    }",
      "}"
    ]
  },
  "And Assignment Operator" : {
    "prefix" : "myandassignment",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: d806e8c2-8063-4883-92d1-99c4faa22cfe",
      "infix operator &&=: AssignmentPrecedence",
      "",
      "\/**",
      " - Remark:",
      " 短絡評価されないので注意。",
      " たとえば`x`が`false`の場合、`x = x && f()`では`f()`は評価されないが、`x &&= f()`では`f()`は評価される。",
      " *\/",
      "func &&= (lhs: inout Bool, rhs: Bool) {",
      "    lhs = lhs && rhs",
      "}",
      ""
    ]
  },
  "Count" : {
    "prefix" : "mycount",
    "description" : "",
    "body" : [
      "extension Sequence {",
      "    \/\/\/ ```",
      "    \/\/\/ assert([1, 2, 3, 4, 5].count(where: { \\$0 % 2 == 1 }) == 3)",
      "    \/\/\/ ```",
      "    func count(where predicate: (Element) -> Bool) -> Int {",
      "        var result = 0",
      "        for element in self {",
      "            if predicate(element) {",
      "                result += 1",
      "            }",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testCount() {",
      "    assert([1, 2, 3, 4, 5].count(where: { \\$0 % 2 == 1 }) == 3)",
      "    assert([].count(where: { \\$0 % 2 == 1 }) == 0)",
      "}",
      "",
      "testCount()",
      ""
    ]
  },
  "Suffix Sum" : {
    "prefix" : "mysuffixsum",
    "description" : "",
    "body" : [
      "extension Collection where Element: AdditiveArithmetic {",
      "    \/\/\/ 後方累積和",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ assert([].suffixSum() == [0])",
      "    \/\/\/ assert([1, 2, 3, 4, 5].suffixSum() == [15, 14, 12, 9, 5, 0])",
      "    \/\/\/ ```",
      "    func suffixSum() -> [Element] {",
      "        var result: [Element] = [.zero]",
      "        for element in reversed() {",
      "            result.append(result.last! + element)",
      "        }",
      "        return result.reversed()",
      "    }",
      "}",
      "",
      "func testSuffixSum() {",
      "    assert([].suffixSum() == [0])",
      "    assert([1, 2, 3, 4, 5].suffixSum() == [15, 14, 12, 9, 5, 0])",
      "}",
      "",
      "testSuffixSum()",
      ""
    ]
  },
  "zip" : {
    "prefix" : "myzip",
    "description" : "",
    "body" : [
      "func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> [(A.Element, B.Element, C.Element)] where A: Sequence, B: Sequence, C: Sequence {",
      "    zip(a, zip(b, c)).map { (\\$0.0, \\$0.1.0, \\$0.1.1) }",
      "}",
      "",
      "func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> [(A.Element, B.Element, C.Element, D.Element)] where A: Sequence, B: Sequence, C: Sequence, D: Sequence {",
      "    zip(a, zip(b, zip(c, d))).map { (\\$0.0, \\$0.1.0, \\$0.1.1.0, \\$0.1.1.1) }",
      "}"
    ]
  },
  "Ordering" : {
    "prefix" : "myordering",
    "description" : "",
    "body" : [
      "enum Ordering {",
      "    case less",
      "    case equal",
      "    case greater",
      "}",
      "",
      "extension Comparable {",
      "    func compare(other: Self) -> Ordering {",
      "        if self == other {",
      "            return .equal",
      "        } else if self < other {",
      "            return .less",
      "        } else {",
      "            return .greater",
      "        }",
      "    }",
      "}"
    ]
  },
  "Main" : {
    "prefix" : "mymain",
    "description" : "",
    "body" : [
      "func main() {",
      "    var scanner = Scanner()",
      "}",
      "",
      "main()",
      "",
      "\/\/ snippet_id: 8d82878e-4927-4f5a-a7f3-51c9668553a2",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Scanner {",
      "    private var elements = [String]()",
      "    private var index = 0",
      "    ",
      "    mutating func peek() -> String {",
      "        while elements.count == index {",
      "            elements = readLine()!.split(separator: \" \").map(\\.description)",
      "            index = 0",
      "        }",
      "        return elements[index]",
      "    }",
      "    ",
      "    mutating func nextString() -> String {",
      "        defer {",
      "            index += 1",
      "        }",
      "        return peek()",
      "    }",
      "    ",
      "    mutating func nextStrings(count n: Int) -> [String] {",
      "        return (0 ..< n).map { _ in nextString() }",
      "    }",
      "    ",
      "    mutating func nextInt() -> Int {",
      "        return Int(nextString())!",
      "    }",
      "    ",
      "    mutating func nextInts(count n: Int) -> [Int] {",
      "        return (0 ..< n).map { _ in nextInt() }",
      "    }",
      "    ",
      "    mutating func nextPairInts(count n: Int) -> ([Int], [Int]) {",
      "        var a = [Int]()",
      "        var b = [Int]()",
      "        for _ in 0 ..< n {",
      "            a.append(nextInt())",
      "            b.append(nextInt())",
      "        }",
      "        return (a, b)",
      "    }",
      "    ",
      "    mutating func nextDouble() -> Double {",
      "        return Double(nextString())!",
      "    }",
      "}",
      ""
    ]
  },
  "Union Find" : {
    "prefix" : "myuf",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 77ea187d-9248-473e-b09b-4876c2f7563e",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "\/\/\/ [https:\/\/ja.wikipedia.org\/wiki\/素集合データ構造](https:\/\/ja.wikipedia.org\/wiki\/素集合データ構造)",
      "protocol UnionFind {",
      "    associatedtype Element",
      "",
      "    mutating func find(_ v: Element) -> Element",
      "    mutating func unite(_ u: Element, _ v: Element)",
      "    mutating func count(_ u: Element) -> Int",
      "}",
      "",
      "extension UnionFind where Element: Equatable {",
      "    mutating func same(_ x: Element, _ y: Element) -> Bool {",
      "        find(x) == find(y)",
      "    }",
      "}",
      "",
      "struct ArrayUnionFind: UnionFind {",
      "    typealias Element = Int",
      "",
      "    private var parent: [Int]",
      "    private var count: [Int]",
      "",
      "    init(_ n: Int) {",
      "        parent = Array(0 ..< n)",
      "        count = [Int](repeating: 1, count: n)",
      "    }",
      "",
      "    mutating func find(_ v: Element) -> Element {",
      "        if v == parent[v] {",
      "            return v",
      "        }",
      "        parent[v] = find(parent[v])",
      "        return parent[v]",
      "    }",
      "",
      "    mutating func unite(_ u: Element, _ v: Element) {",
      "        var u = find(u)",
      "        var v = find(v)",
      "        guard u != v else { return }",
      "        if count[u] < count[v] {",
      "            swap(&u, &v)",
      "        }",
      "        count[u] += count[v]",
      "        parent[v] = u",
      "    }",
      "",
      "    mutating func count(_ u: Element) -> Int {",
      "        count[find(u)]",
      "    }",
      "",
      "    \/\/\/ ```",
      "    \/\/\/ var uf = ArrayUnionFind(5)",
      "    \/\/\/ uf.unite(0, 1)",
      "    \/\/\/ uf.unite(0, 2)",
      "    \/\/\/ uf.unite(3, 4)",
      "    \/\/\/ assert(uf.connectedComponents() == [0: [0, 1, 2], 3: [3, 4]])",
      "    \/\/\/ ```",
      "    mutating func connectedComponents() -> [Element: [Element]] {",
      "        var result: [Element: [Element]] = [:]",
      "        for element in parent.indices {",
      "            result[find(element), default: []].append(element)",
      "        }",
      "        return result",
      "    }",
      "}",
      "",
      "func testArrayUnionFind() {",
      "    func testFind() {",
      "        var uf = ArrayUnionFind(5)",
      "        uf.unite(0, 1)",
      "        uf.unite(0, 2)",
      "        uf.unite(3, 4)",
      "        assert(uf.find(0) == uf.find(1))",
      "        assert(uf.find(0) == uf.find(2))",
      "        assert(uf.find(3) == uf.find(4))",
      "        assert(uf.find(0) != uf.find(3))",
      "        assert(uf.same(0, 1))",
      "        assert(uf.same(0, 2))",
      "        assert(uf.same(3, 4))",
      "        assert(!uf.same(0, 3))",
      "    }",
      "",
      "    func testCount() {",
      "        var uf = ArrayUnionFind(5)",
      "        uf.unite(0, 1)",
      "        uf.unite(0, 2)",
      "        uf.unite(3, 4)",
      "        assert(uf.count(0) == 3)",
      "        assert(uf.count(1) == 3)",
      "        assert(uf.count(2) == 3)",
      "        assert(uf.count(3) == 2)",
      "        assert(uf.count(4) == 2)",
      "    }",
      "",
      "    func testConnectedComponents() {",
      "        var uf = ArrayUnionFind(5)",
      "        uf.unite(0, 1)",
      "        uf.unite(0, 2)",
      "        uf.unite(3, 4)",
      "        assert(uf.connectedComponents() == [0: [0, 1, 2], 3: [3, 4]])",
      "    }",
      "",
      "    testFind()",
      "    testCount()",
      "    testConnectedComponents()",
      "}",
      "",
      "testArrayUnionFind()",
      "",
      "struct HashedUnionFind<Element>: UnionFind where Element: Hashable {",
      "    typealias Element = Element",
      "",
      "    private var parent: [Element: Element]",
      "    private var count: [Element: Int]",
      "",
      "    init() {",
      "        parent = [:]",
      "        count = [:]",
      "    }",
      "",
      "    \/\/\/ `v`の代表元を返す。",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var uf = HashedUnionFind<Int>()",
      "    \/\/\/ uf.unite(0, 1)",
      "    \/\/\/ uf.unite(0, 2)",
      "    \/\/\/ uf.unite(3, 4)",
      "    \/\/\/ assert(uf.find(0) == uf.find(1))",
      "    \/\/\/ assert(uf.find(0) == uf.find(2))",
      "    \/\/\/ assert(uf.find(3) == uf.find(4))",
      "    \/\/\/ ```",
      "    \/\/\/",
      "    \/\/\/ - Complexity: 償却O(log n)",
      "    mutating func find(_ v: Element) -> Element {",
      "        guard let p = parent[v] else { return v }",
      "        if v == p {",
      "            return v",
      "        } else {",
      "            let newParent = find(p)",
      "            parent[v] = newParent",
      "            return newParent",
      "        }",
      "    }",
      "",
      "    \/\/\/ 頂点`u`と頂点`v`を辺で繋ぐ。",
      "    \/\/\/",
      "    \/\/\/ - Complexity: 償却O(log n)",
      "    mutating func unite(_ u: Element, _ v: Element) {",
      "        var u = find(u)",
      "        var v = find(v)",
      "        guard u != v else { return }",
      "        if count[u, default: 1] < count[v, default: 1] {",
      "            swap(&u, &v)",
      "        }",
      "        count[u, default: 1] += count[v, default: 1]",
      "        parent[v] = u",
      "    }",
      "",
      "    \/\/\/ 頂点`u`が属する連結成分の頂点数を返す。",
      "    \/\/\/",
      "    \/\/\/ ```",
      "    \/\/\/ var uf = HashedUnionFind<Int>()",
      "    \/\/\/ uf.unite(0, 1)",
      "    \/\/\/ uf.unite(0, 2)",
      "    \/\/\/ uf.unite(3, 4)",
      "    \/\/\/ assert(uf.count(0) == 3)",
      "    \/\/\/ assert(uf.count(1) == 3)",
      "    \/\/\/ assert(uf.count(2) == 3)",
      "    \/\/\/ assert(uf.count(3) == 2)",
      "    \/\/\/ assert(uf.count(4) == 2)",
      "    \/\/\/ ```",
      "    \/\/\/",
      "    \/\/\/ - Complexity: 償却O(log n)",
      "    mutating func count(_ u: Element) -> Int {",
      "        count[find(u), default: 1]",
      "    }",
      "}",
      "",
      "func testHashedUnionFind() {",
      "    func testFind() {",
      "        var uf = HashedUnionFind<Int>()",
      "        uf.unite(0, 1)",
      "        uf.unite(0, 2)",
      "        uf.unite(3, 4)",
      "        assert(uf.find(0) == uf.find(1))",
      "        assert(uf.find(0) == uf.find(2))",
      "        assert(uf.find(3) == uf.find(4))",
      "        assert(uf.find(0) != uf.find(3))",
      "        assert(uf.same(0, 1))",
      "        assert(uf.same(0, 2))",
      "        assert(uf.same(3, 4))",
      "        assert(!uf.same(0, 3))",
      "    }",
      "",
      "    func testCount() {",
      "        var uf = HashedUnionFind<Int>()",
      "        uf.unite(0, 1)",
      "        uf.unite(0, 2)",
      "        uf.unite(3, 4)",
      "        assert(uf.count(0) == 3)",
      "        assert(uf.count(1) == 3)",
      "        assert(uf.count(2) == 3)",
      "        assert(uf.count(3) == 2)",
      "        assert(uf.count(4) == 2)",
      "    }",
      "",
      "    testFind()",
      "    testCount()",
      "}",
      "",
      "testHashedUnionFind()",
      "",
      ""
    ]
  },
  "Deque" : {
    "prefix" : "mydeque",
    "description" : "",
    "body" : [
      "struct Deque<Element> {",
      "    private var elements: [Element?]",
      "    private var l: Int = 0",
      "    private var r: Int = 0",
      "",
      "    var count: Int {",
      "        r - l",
      "    }",
      "",
      "    var capacity: Int {",
      "        elements.count",
      "    }",
      "",
      "    var isEmpty: Bool {",
      "        count == 0",
      "    }",
      "",
      "    init() {",
      "        self.elements = [Element?](repeating: nil, count: 1)",
      "    }",
      "",
      "    private mutating func reallocate() {",
      "        guard count == elements.count else { return }",
      "        var newElements = [Element?](repeating: nil, count: elements.count * 2)",
      "        for i in l ..< r {",
      "            newElements[i - l] = elements[index(i)]",
      "        }",
      "        elements = newElements",
      "        l = 0",
      "        r = elements.count \/ 2",
      "    }",
      "",
      "    private mutating func index(_ k: Int) -> Int {",
      "        var k = k % elements.count",
      "        if k < 0 {",
      "            k += elements.count",
      "        }",
      "        return k",
      "    }",
      "",
      "    private mutating func release(_ k: Int) -> Element {",
      "        let k = index(k)",
      "        let result = elements[k]!",
      "        elements[k] = nil",
      "        return result",
      "    }",
      "",
      "    mutating func pushFront(_ newElement: Element) {",
      "        reallocate()",
      "        l -= 1",
      "        elements[index(l)] = newElement",
      "    }",
      "",
      "    mutating func pushBack(_ newElement: Element) {",
      "        reallocate()",
      "        elements[index(r)] = newElement",
      "        r += 1",
      "    }",
      "",
      "    mutating func popFront() -> Element? {",
      "        guard l < r else { return nil }",
      "        defer { l += 1 }",
      "        return release(l)",
      "    }",
      "",
      "    mutating func popBack() -> Element? {",
      "        guard l < r else { return nil }",
      "        r -= 1",
      "        return release(r)",
      "    }",
      "}       "
    ]
  },
  "Scanner" : {
    "prefix" : "myscanner",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 8d82878e-4927-4f5a-a7f3-51c9668553a2",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "struct Scanner {",
      "    private var elements = [String]()",
      "    private var index = 0",
      "",
      "    mutating func peek() -> String {",
      "        while elements.count == index {",
      "            elements = readLine()!.split(separator: \" \").map(\\.description)",
      "            index = 0",
      "        }",
      "        return elements[index]",
      "    }",
      "",
      "    mutating func nextString() -> String {",
      "        defer {",
      "            index += 1",
      "        }",
      "        return peek()",
      "    }",
      "",
      "    mutating func nextStrings(count n: Int) -> [String] {",
      "        return (0 ..< n).map { _ in nextString() }",
      "    }",
      "",
      "    mutating func nextInt() -> Int {",
      "        return Int(nextString())!",
      "    }",
      "",
      "    mutating func nextInts(count n: Int) -> [Int] {",
      "        return (0 ..< n).map { _ in nextInt() }",
      "    }",
      "",
      "    mutating func nextPairInts(count n: Int) -> ([Int], [Int]) {",
      "        var a = [Int]()",
      "        var b = [Int]()",
      "        for _ in 0 ..< n {",
      "            a.append(nextInt())",
      "            b.append(nextInt())",
      "        }",
      "        return (a, b)",
      "    }",
      "",
      "    mutating func nextDouble() -> Double {",
      "        return Double(nextString())!",
      "    }",
      "}",
      ""
    ]
  },
  "Enumerate Divisors" : {
    "prefix" : "mydivisors",
    "description" : "",
    "body" : [
      "extension Int {",
      "    \/\/\/ ```",
      "    \/\/\/ assert(12.divisors() == [1, 2, 3, 4, 6, 12])",
      "    \/\/\/ ```",
      "    func divisors() -> [Int] {",
      "        precondition(self >= 1)",
      "        var i = 1",
      "        var result = [Int]()",
      "        while i * i <= self {",
      "            if self % i == 0 {",
      "                result.append(i)",
      "                if i * i != self {",
      "                    result.append(self \/ i)",
      "                }",
      "            }",
      "            i += 1",
      "        }",
      "        return result.sorted()",
      "    }",
      "}",
      "",
      "func testDivisors() {",
      "    assert(1.divisors() == [1])",
      "    assert(2.divisors() == [1, 2])",
      "    assert(3.divisors() == [1, 3])",
      "    assert(4.divisors() == [1, 2, 4])",
      "    assert(5.divisors() == [1, 5])",
      "    assert(6.divisors() == [1, 2, 3, 6])",
      "    assert(7.divisors() == [1, 7])",
      "    assert(8.divisors() == [1, 2, 4, 8])",
      "    assert(9.divisors() == [1, 3, 9])",
      "    assert(10.divisors() == [1, 2, 5, 10])",
      "    assert(11.divisors() == [1, 11])",
      "    assert(12.divisors() == [1, 2, 3, 4, 6, 12])",
      "    assert(16.divisors() == [1, 2, 4, 8, 16])",
      "}",
      "",
      "testDivisors()",
      ""
    ]
  },
  "RMQmin" : {
    "prefix" : "myrmqmin",
    "description" : "",
    "body" : [
      "struct RMQmin {",
      "    private var nodes: [Int]",
      "    private var size: Int",
      "",
      "    init(_ n: Int) {",
      "        var m = 1",
      "        while m < n {",
      "            m *= 2",
      "        }",
      "        size = m",
      "        nodes = .init(repeating: Int.max, count: m * 2)",
      "    }",
      "",
      "    mutating func update(_ k: Int, _ value: Int) {",
      "        var k = k + size - 1",
      "        nodes[k] = value",
      "        while k > 0 {",
      "            k = (k - 1) \/ 2",
      "            nodes[k] = min(nodes[k * 2 + 1], nodes[k * 2 + 2])",
      "        }",
      "    }",
      "",
      "    func query(_ a: Int, _ b: Int) -> Int {",
      "        func f(_ k: Int, _ l: Int, _ r: Int) -> Int {",
      "            if a <= l && r <= b {",
      "                return nodes[k]",
      "            }",
      "            if r <= a || b <= l {",
      "                return Int.max",
      "            }",
      "            let vl = f(k * 2 + 1, l, (l + r) \/ 2)",
      "            let vr = f(k * 2 + 2, (l + r) \/ 2, r)",
      "            return min(vl, vr)",
      "        }",
      "        return f(0, 0, size)",
      "    }",
      "}"
    ]
  },
  "LCM" : {
    "prefix" : "mylcm",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: b31b9e45-2594-4269-a880-ac62284174cf",
      "func lcm(_ a: Int, _ b: Int) -> Int {",
      "    a \/ gcd(a, b) * b",
      "}",
      "",
      "func testLCM() {",
      "    assert(lcm(1, 1) == 1)",
      "    assert(lcm(1, 5) == 5)",
      "    assert(lcm(5, 1) == 5)",
      "    assert(lcm(6, 10) == 30)",
      "    assert(lcm(4, 12) == 12)",
      "    assert(lcm(8, 12) == 24)",
      "}",
      "",
      "testLCM()"
    ]
  },
  "Uniqued Equatable" : {
    "prefix" : "myuniquedequatable",
    "description" : "",
    "body" : [
      "extension Array where Element: Equatable {",
      "    func uniqued() -> [Element] {",
      "        var result = [Element]()",
      "        for element in self where !result.contains(element) {",
      "            result.append(element)",
      "        }",
      "        return result",
      "    }",
      "}"
    ]
  },
  "Uniqued Hashable" : {
    "prefix" : "myuniquedhashable",
    "description" : "",
    "body" : [
      "extension Array where Element: Hashable {",
      "    func uniqued() -> [Element] {",
      "        return Array(Set(self))",
      "    }",
      "}",
      ""
    ]
  },
  "Int Length" : {
    "prefix" : "myintlength",
    "description" : "",
    "body" : [
      "extension Int {",
      "    var length: Int {",
      "        if self < 0 {",
      "            return (-self).length",
      "        } else if self == 0 {",
      "            return 0",
      "        } else {",
      "            return 1 + (self \/ 10).length",
      "        }",
      "    }",
      "}",
      "",
      "func testIntLength() {",
      "    assert(0.length == 0)",
      "    assert(1.length == 1)",
      "    assert(9.length == 1)",
      "    assert(10.length == 2)",
      "    assert(99.length == 2)",
      "    assert(100.length == 3)",
      "    assert(999.length == 3)",
      "    assert(1000.length == 4)",
      "    assert(9999.length == 4)",
      "    assert(10000.length == 5)",
      "    assert(99999.length == 5)",
      "}",
      "",
      "testIntLength()",
      ""
    ]
  },
  "Divide Then Floor" : {
    "prefix" : "myfloor",
    "description" : "",
    "body" : [
      "\/\/ snippet_id: 9fade958-2a9a-4341-a735-9162b9cc09c4",
      "\/\/ https:\/\/github.com\/semisagi0\/kyopro-snippet",
      "infix operator \/-: MultiplicationPrecedence \/\/ 切り下げ",
      "",
      "\/\/ floor(lhs\/rhs)と等価。",
      "func \/- (lhs: Int, rhs: Int) -> Int {",
      "    if rhs < 0 {",
      "        return -lhs \/- -rhs",
      "    }",
      "    return lhs >= 0 ? lhs \/ rhs : (lhs - rhs + 1) \/ rhs",
      "}",
      "",
      "func testFloorDivision() {",
      "    assert(0 \/- 3 == 0)",
      "    assert(5 \/- 2 == 2)",
      "    assert(6 \/- 2 == 3)",
      "    assert(-3 \/- 2 == -2)",
      "    assert(-4 \/- 2 == -2)",
      "",
      "    assert(0 \/- -3 == 0)",
      "    assert(-5 \/- -2 == 2)",
      "    assert(-6 \/- -2 == 3)",
      "    assert(3 \/- -2 == -2)",
      "    assert(4 \/- -2 == -2)",
      "}",
      "",
      "testFloorDivision()"
    ]
  }
}